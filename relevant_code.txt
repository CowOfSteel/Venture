

----- .\client\src\App.css -----

.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


----- .\client\src\App.js -----

// ./client/src/App.js
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import Home from './components/Home';
import CharacterList from './components/CharacterList';
import CharacterForm from './components/CharacterForm';
import Login from './components/Login';
import Register from './components/Register';
import Welcome from './components/Welcome';
import Layout from './components/Layout';
import ProtectedRoute from './components/ProtectedRoute';
import ViewCharacter from './components/ViewCharacter';
import AttributeCreationWrapper from './components/AttributeCreationWrapper';
import AttributeCreationStarter from './components/AttributeCreationStarter';
import NewCharacterChoice from './components/NewCharacterChoice';
import BackgroundCreation from './components/BackgroundCreation';
import Contacts from './components/Contacts';
import Edges from './components/Edges';
import EdgeSelection from './components/EdgeSelection';
import FocusSelection from './components/FocusSelection';
import FinalSteps from './components/FinalSteps';

function App() {
  return (
    <AuthProvider>
      <Router>
        <Routes>
          {/* All pages share the Layout */}
          <Route element={<Layout />}>
            {/* Protected routes */}
            <Route path="/home" element={<ProtectedRoute><Home /></ProtectedRoute>} />
            <Route path="/characters" element={<ProtectedRoute><CharacterList /></ProtectedRoute>} />
            <Route path="/new" element={<ProtectedRoute><NewCharacterChoice /></ProtectedRoute>} />
            <Route path="/new/manual" element={<ProtectedRoute><CharacterForm /></ProtectedRoute>} />
            <Route path="/new/discover" element={<ProtectedRoute><AttributeCreationStarter /></ProtectedRoute>} />
            <Route path="/characters/:id/attributes" element={<ProtectedRoute><AttributeCreationWrapper /></ProtectedRoute>} />
            <Route path="/characters/:id/backgrounds" element={<ProtectedRoute><BackgroundCreation /></ProtectedRoute>} />
            <Route path="/edges" element={<ProtectedRoute><Edges /></ProtectedRoute>} />
            <Route path="/characters/:id/contacts" element={<ProtectedRoute><Contacts /></ProtectedRoute>} />
            <Route path="/characters/:id/edges" element={<ProtectedRoute><EdgeSelection /></ProtectedRoute>} />
            <Route path="/characters/:id/foci" element={<ProtectedRoute><FocusSelection /></ProtectedRoute>} />
            <Route path="/characters/:id/final" element={<ProtectedRoute><FinalSteps /></ProtectedRoute>} />
            <Route path="/characters/:id" element={<ProtectedRoute><ViewCharacter /></ProtectedRoute>} />

            {/* Public routes */}
            <Route path="/welcome" element={<Welcome />} />
            <Route path="/login" element={<Login />} />
            <Route path="/register" element={<Register />} />

            {/* Catch-all redirect */}
            <Route path="*" element={<ProtectedRoute><Navigate to="/home" replace /></ProtectedRoute>} />
          </Route>
        </Routes>
      </Router>
    </AuthProvider>
  );
}

export default App;


----- .\client\src\App.test.js -----

import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


----- .\client\src\dark-theme.css -----

/* dark-theme.css */

body {
  background-color: #121212;
  color: #e0e0e0;
  font-family: 'Roboto', 'Rajdhani', sans-serif;
}

nav {
  background-color: rgba(255,255,255,0.05);
  padding: 10px;
  border-bottom: 1px solid #0fffc1;
}

nav a,
nav button {
  color: #0fffc1;
  text-decoration: none;
  font-weight: bold;
  margin-right: 10px;
  transition: 0.3s ease;
}

nav a:hover,
nav button:hover {
  color: #ff2079;
  text-shadow: 0 0 5px #ff2079, 0 0 10px #ff2079;
}

button,
input {
  background-color: rgba(255,255,255,0.1);
  border: 1px solid #0fffc1;
  border-radius: 6px;
  padding: 8px 12px;
  color: #e0e0e0;
  outline: none;
  transition: box-shadow 0.2s ease;
}

button:hover,
input:focus {
  box-shadow: 0 0 10px #0fffc1, inset 0 0 5px #0fffc1;
}

form div {
  margin-bottom: 15px;
}

input[type="number"],
input[type="text"],
input[type="password"],
input[type="email"] {
  width: 100%;
}

.card {
  background-color: rgba(255,255,255,0.05);
  padding: 20px;
  border-radius: 6px;
  box-shadow: 0 0 5px rgba(0,0,0,0.6);
  margin-bottom: 20px;
}

.error {
  color: #f7ff00;
}

.success {
  color: #0fffc1;
}


----- .\client\src\index.css -----

/* index.css */
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


----- .\client\src\index.js -----

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import reportWebVitals from './reportWebVitals';
import './index.css';
import './dark-theme.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

----- .\client\src\reportWebVitals.js -----

const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


----- .\client\src\setupTests.js -----

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


----- .\client\src\components\AttributeCreation.js -----

import React, { useState, useEffect } from 'react';
import axios from '../services/api';
import { useNavigate } from 'react-router-dom';

const ATTRIBUTE_NAMES = ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"];
const MANUAL_OPTIONS = [14, 12, 11, 10, 9, 7];

const roll3d6 = () => {
  let total = 0;
  for (let i = 0; i < 3; i++) {
    total += Math.floor(Math.random() * 6) + 1;
  }
  return total;
};

const AttributeCreation = ({ characterId }) => {
  const [mode, setMode] = useState("random"); // "random" or "manual"
  const [attributes, setAttributes] = useState({
    strength: 10,
    dexterity: 10,
    constitution: 10,
    intelligence: 10,
    wisdom: 10,
    charisma: 10
  });
  const [manualAttributes, setManualAttributes] = useState({
    strength: null,
    dexterity: null,
    constitution: null,
    intelligence: null,
    wisdom: null,
    charisma: null
  });
  const [error, setError] = useState(null);
  const navigate = useNavigate();

  useEffect(() => {
    if (mode === "manual") {
      setManualAttributes({
        strength: null,
        dexterity: null,
        constitution: null,
        intelligence: null,
        wisdom: null,
        charisma: null
      });
    }
  }, [mode]);

  const handleRoll = () => {
    const newAttributes = {};
    ATTRIBUTE_NAMES.forEach(attr => {
      newAttributes[attr] = roll3d6();
    });
    setAttributes(newAttributes);
  };

  const handleManualChange = (attr, value) => {
    setManualAttributes(prev => ({
      ...prev,
      [attr]: value === "" ? null : parseInt(value, 10)
    }));
  };

  // Return only the available manual options that haven't been picked yet.
  const getAvailableOptions = (currentAttr) => {
    const usedValues = ATTRIBUTE_NAMES.filter(a => a !== currentAttr)
      .map(a => manualAttributes[a])
      .filter(v => v !== null);
    return MANUAL_OPTIONS.filter(option =>
      !usedValues.includes(option) || option === manualAttributes[currentAttr]
    );
  };

  const handleConfirm = async () => {
    if (mode === "manual") {
      // Ensure every attribute has a selection.
      for (let attr of ATTRIBUTE_NAMES) {
        if (manualAttributes[attr] === null) {
          setError("Please select a value for every attribute.");
          return;
        }
      }
      setAttributes(manualAttributes);
      setError(null);
      try {
        await axios.patch(`/characters/${characterId}/`, {
          vitals: { ...manualAttributes },
          creation_data: { step: "attributes" }
        });
        navigate(`/characters/${characterId}/backgrounds`);
      } catch (err) {
        console.error("Error updating attributes:", err);
        setError("Failed to update character attributes.");
      }
    } else {
      // random mode
      try {
        await axios.patch(`/characters/${characterId}/`, {
          vitals: { ...attributes },
          creation_data: { step: "attributes" }
        });
        navigate(`/characters/${characterId}/backgrounds`);
      } catch (err) {
        console.error("Error updating attributes:", err);
        setError("Failed to update character attributes.");
      }
    }
  };

  return (
    <div className="card">
      <h2>Character Creation: Attributes</h2>
      <div>
        <label>
          <input
            type="radio"
            value="random"
            checked={mode === "random"}
            onChange={() => setMode("random")}
          />
          Roll Attributes Randomly
        </label>
        <label style={{ marginLeft: '20px' }}>
          <input
            type="radio"
            value="manual"
            checked={mode === "manual"}
            onChange={() => setMode("manual")}
          />
          Assign Manually
        </label>
      </div>

      {mode === "random" && (
        <div>
          <button onClick={handleRoll}>Roll Attributes</button>
          <div style={{ marginTop: '10px' }}>
            {ATTRIBUTE_NAMES.map(attr => (
              <div key={attr}>
                <strong>{attr.charAt(0).toUpperCase() + attr.slice(1)}:</strong> {attributes[attr]}
              </div>
            ))}
          </div>
        </div>
      )}

      {mode === "manual" && (
        <div>
          {ATTRIBUTE_NAMES.map(attr => (
            <div key={attr} style={{ marginBottom: '10px' }}>
              <label>
                {attr.charAt(0).toUpperCase() + attr.slice(1)}:
                <select
                  value={manualAttributes[attr] !== null ? manualAttributes[attr] : ""}
                  onChange={(e) => handleManualChange(attr, e.target.value)}
                  style={{ marginLeft: '10px' }}
                >
                  <option value="">Select a value</option>
                  {getAvailableOptions(attr).map(option => (
                    <option key={option} value={option}>{option}</option>
                  ))}
                </select>
              </label>
            </div>
          ))}
        </div>
      )}

      {error && <div style={{ color: 'red', marginTop: '10px' }}>{error}</div>}

      <div style={{ marginTop: '20px' }}>
        <button onClick={handleConfirm}>Confirm Attributes</button>
      </div>
    </div>
  );
};

export default AttributeCreation;


----- .\client\src\components\AttributeCreationStarter.js -----

// client/src/components/AttributeCreationStarter.js
import React, { useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../services/api';

const AttributeCreationStarter = () => {
  const navigate = useNavigate();
  // A ref to ensure we only call createInProgressCharacter once in Strict Mode
  const hasCreatedRef = useRef(false);

  useEffect(() => {
    // This check will prevent the function from running again in dev’s Strict Mode
    if (hasCreatedRef.current) return;
    hasCreatedRef.current = true;

    const createInProgressCharacter = async () => {
      try {
        const response = await api.post('/characters/', {
          name: "Unnamed Character",
          is_complete: false,
          creation_data: { step: "attributes" }
        });
        const newCharacterId = response.data.id;
        navigate(`/characters/${newCharacterId}/attributes`);
      } catch (error) {
        console.error("Failed to create new character:", error);
      }
    };

    createInProgressCharacter();
  }, [navigate]); // Note the empty dependency array

  return (
    <div className="card">
      <p>Starting your new character...</p>
    </div>
  );
};

export default AttributeCreationStarter;


----- .\client\src\components\AttributeCreationWrapper.js -----

import React from 'react';
import { useParams } from 'react-router-dom';
import AttributeCreation from './AttributeCreation';

const AttributeCreationWrapper = () => {
  const { id } = useParams();
  return <AttributeCreation characterId={id} />;
};

export default AttributeCreationWrapper;


----- .\client\src\components\BackgroundCreation.js -----

// client/src/components/BackgroundCreation.js
import React, { useState, useEffect } from 'react';
import axios from '../services/api';
import { useNavigate, useParams } from 'react-router-dom';

const ATTRIBUTE_NAMES = ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"];
const ANY_COMBAT_OPTIONS = ["Punch", "Shoot", "Stab"];
const ANY_AVAILABLE_SKILLS = [
  "Administer", "Connect", "Drive", "Exert", "Fix", "Heal",
  "Know", "Lead", "Notice", "Perform", "Program", "Punch",
  "Shoot", "Sneak", "Stab", "Survive", "Talk", "Trade", "Work"
];

const BackgroundCreation = () => {
  const [backgrounds, setBackgrounds] = useState([]);
  const [selectedBackground, setSelectedBackground] = useState(null);
  const [mode, setMode] = useState('roll'); // 'roll' or 'manual'
  const [rollData, setRollData] = useState({ growth_rolls: [], learning_rolls: [] });
  const [computedResults, setComputedResults] = useState([]); // results from dice rolls
  const [manualChoices, setManualChoices] = useState([]); // manual pick choices
  const [error, setError] = useState(null);
  // Pending ANY picks now as an array (multiple ANY picks allowed)
  const [pendingAnySkills, setPendingAnySkills] = useState([]);
  // BONUS distributions state from Phase 2
  const [bonusDistributions, setBonusDistributions] = useState({});

  const navigate = useNavigate();
  const { id } = useParams(); // character ID

  useEffect(() => {
    axios.get('/backgrounds/')
      .then(res => setBackgrounds(res.data))
      .catch(err => setError('Failed to load backgrounds.'));
  }, []);

  const handleBackgroundSelect = (bg) => {
    setSelectedBackground(bg);
    setRollData({ growth_rolls: [], learning_rolls: [] });
    setComputedResults([]);
    setManualChoices([]);
    setError(null);
    setPendingAnySkills([]);
    setBonusDistributions({});
  };

  const rollD6 = () => Math.floor(Math.random() * 6) + 1;
  const rollD8 = () => Math.floor(Math.random() * 8) + 1;

  const handleRoll = (tableType) => {
    const totalRolls = rollData.growth_rolls.length + rollData.learning_rolls.length;
    if (totalRolls >= 3) return;

    if (tableType === 'growth') {
      const roll = rollD6();
      setRollData(prev => ({ ...prev, growth_rolls: [...prev.growth_rolls, roll] }));
      if (selectedBackground && selectedBackground.growth_table) {
        const result = selectedBackground.growth_table[String(roll)];
        if (result) {
          if (result.type === "ATTRIBUTE" &&
              ["ANY", "PHYSICAL", "MENTAL"].includes(result.category.toUpperCase())) {
            // Queue this bonus distribution result for later assignment.
            setComputedResults(prev => [...prev, result]);
          } else if (
            result.type === "SKILL" &&
            (result.name.toLowerCase() === "any" || result.name.toLowerCase() === "any_combat")
          ) {
            // Add a new ANY pick to the array.
            setPendingAnySkills(prev => [...prev, result.name.toLowerCase()]);
            setComputedResults(prev => [...prev, result]);
          } else {
            setComputedResults(prev => [...prev, result]);
          }
        }
      }
    } else if (tableType === 'learning') {
      const roll = rollD8();
      setRollData(prev => ({ ...prev, learning_rolls: [...prev.learning_rolls, roll] }));
      if (selectedBackground && selectedBackground.learning_table) {
        const result = selectedBackground.learning_table[String(roll)];
        if (result) {
          if (
            result.type === "SKILL" &&
            (result.name.toLowerCase() === "any" || result.name.toLowerCase() === "any_combat")
          ) {
            setPendingAnySkills(prev => [...prev, result.name.toLowerCase()]);
            setComputedResults(prev => [...prev, result]);
          } else {
            setComputedResults(prev => [...prev, result]);
          }
        }
      }
    }
  };

  // STEP 3 IMPLEMENTATION: Update ANY-skill selection to work with our pendingAnySkills array.
  // Also, filter out any option that was already chosen via ANY picks.
  const handleAnySkillSelection = (index, selectedSkill) => {
    // Determine which ANY skills have already been resolved:
    const resolvedAnySkills = computedResults
      .filter(r => r.type === "SKILL" && r.name.toLowerCase() !== "any" && r.name.toLowerCase() !== "any_combat")
      .map(r => r.name.toLowerCase());
    // If the selected skill is already chosen, do nothing.
    if (resolvedAnySkills.includes(selectedSkill.toLowerCase())) return;

    let anySkillCount = 0;
    setComputedResults(prevResults =>
      prevResults.map(res => {
        if (res.type === "SKILL" && (res.name.toLowerCase() === "any" || res.name.toLowerCase() === "any_combat")) {
          if (anySkillCount === index) {
            return { ...res, name: selectedSkill };
          }
          anySkillCount++;
        }
        return res;
      })
    );
    setPendingAnySkills(prev => {
      const newArray = [...prev];
      newArray.splice(index, 1);
      return newArray;
    });
  };

  // STEP 2/3: Compute bonus results (attribute bonuses) from computedResults.
  const bonusResults = computedResults.filter(
    res => res.type === "ATTRIBUTE" && res.points > 1
  );

  // Handler for bonus distribution completion for a given bonus roll index.
  const handleBonusDistributionComplete = (index, finalAssignment) => {
    setBonusDistributions(prev => ({ ...prev, [index]: {
      category: bonusResults[index].category,
      points: bonusResults[index].points,
      assigned_attributes: finalAssignment
    }}));
  };

  // Calculate allowed attributes for bonus distribution:
  let allowedAttributes = [];
  if (bonusResults.length > 0) {
    // Note: For multiple bonus rolls, each distribution will render its own UI.
    // This variable is used only in the BonusAttributeDistribution component.
    // Here we simply leave allowedAttributes empty.
  }

  // STEP 2/3: Build payload including bonus distributions only if they’re complete.
  const buildPayload = () => {
    let payload = { background_id: selectedBackground.id, mode };
    if (mode === 'roll') {
      payload.growth_rolls = rollData.growth_rolls;
      payload.learning_rolls = rollData.learning_rolls;
      payload.results = computedResults;
      // Ensure bonus distributions are complete for all bonus results.
      if (bonusResults.length > 0) {
        if (Object.keys(bonusDistributions).length !== bonusResults.length) {
          setError("Please complete bonus attribute distribution for all bonus rolls.");
          return null;
        }
        payload.bonus_distribution = Object.values(bonusDistributions);
      }
    } else {
      payload.manual_choices = manualChoices;
    }
    return payload;
  };

  const handleConfirm = () => {
    if (!selectedBackground) {
      setError("Please select a background.");
      return;
    }
    if (mode === 'roll') {
      if ((rollData.growth_rolls.length + rollData.learning_rolls.length) !== 3) {
        setError("Please roll exactly 3 times (combined).");
        return;
      }
      if (computedResults.length !== 3) {
        setError("Results are incomplete. Please complete all bonus distributions.");
        return;
      }
      if (pendingAnySkills.length > 0) {
        setError("Please select bonus skills for all ANY rolls.");
        return;
      }
      if (bonusResults.length > 0 && Object.keys(bonusDistributions).length !== bonusResults.length) {
        setError("Please complete bonus attribute distribution for all bonus rolls.");
        return;
      }
    } else {
      if (manualChoices.length !== 2) {
        setError("Please select exactly 2 manual choices.");
        return;
      }
    }
    const payload = buildPayload();
    if (!payload) return;
    console.log("Sending payload:", payload);
    axios.patch(`/characters/${id}/`, { background_selection: payload })
      .then(res => {
        navigate(`/characters/${id}/contacts`);
      })
      .catch(err => {
        console.error("Error saving background selection:", err.response.data);
        setError("Error saving background selection.");
      });
  };

  return (
    <div className="card">
      <h2>Background Selection</h2>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      {!selectedBackground ? (
        <div>
          <h3>Choose a Background:</h3>
          <ul>
            {backgrounds.map(bg => (
              <li key={bg.id}>
                <button onClick={() => handleBackgroundSelect(bg)}>
                  <strong>{bg.name}</strong>: {bg.description}<br />
                  Free Skill: {bg.free_skill}
                </button>
              </li>
            ))}
          </ul>
        </div>
      ) : (
        <div>
          <h3>{selectedBackground.name} Selected</h3>
          <p>{selectedBackground.description}</p>
          <p>Free Skill: {selectedBackground.free_skill}</p>
          <div>
            <label>
              <input
                type="radio"
                value="roll"
                checked={mode === 'roll'}
                onChange={() => { setMode('roll'); setError(null); }}
              />
              Roll-based Selection
            </label>
            <label style={{ marginLeft: '20px' }}>
              <input
                type="radio"
                value="manual"
                checked={mode === 'manual'}
                onChange={() => { setMode('manual'); setError(null); }}
              />
              Manual Selection
            </label>
          </div>
          {mode === 'roll' && (
            <div>
              <h4>Roll Dice (3 rolls total):</h4>
              <button
                onClick={() => handleRoll('growth')}
                disabled={(rollData.growth_rolls.length + rollData.learning_rolls.length) >= 3}
              >
                Roll d6 for Growth
              </button>
              <button
                onClick={() => handleRoll('learning')}
                disabled={(rollData.growth_rolls.length + rollData.learning_rolls.length) >= 3}
                style={{ marginLeft: '10px' }}
              >
                Roll d8 for Learning
              </button>
              <div>
                <p>Growth Rolls: {rollData.growth_rolls.join(', ')}</p>
                <p>Learning Rolls: {rollData.learning_rolls.join(', ')}</p>
              </div>
              {computedResults.length > 0 && (
                <div>
                  <h4>Results:</h4>
                  <ul>
                    {computedResults.map((res, idx) => (
                      <li key={idx}>
                        {res.type === "ATTRIBUTE" ? (
                          <span>+{res.points} bonus to {res.category} attribute</span>
                        ) : res.type === "SKILL" ? (
                          <span>Gain {res.points} point in skill: {res.name}</span>
                        ) : null}
                      </li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          )}
          {mode === 'manual' && (
            <div>
              <h4>Manual Choices (Select 2):</h4>
              {selectedBackground.manual_table && Object.values(selectedBackground.manual_table)
                .filter(option => option.name.toLowerCase() !== "any" && option.name.toLowerCase() !== "any combat")
                .map(option => (
                  <button
                    key={`${option.name}-${option.points}`}
                    onClick={() => {
                      if (manualChoices.length < 2) {
                        setManualChoices(prev => [...prev, option]);
                      }
                    }}
                    style={{ margin: '5px' }}
                  >
                    {option.name} ({option.points} point{option.points > 1 ? 's' : ''})
                  </button>
                ))}
              <p>Selected: {manualChoices.map(choice => choice.name).join(', ')}</p>
            </div>
          )}
          {pendingAnySkills.length > 0 && (
            <div className="card" style={{ marginTop: '20px', padding: '10px' }}>
              <h4>Select your bonus skill(s):</h4>
              {pendingAnySkills.map((anySkill, index) => {
                // STEP 3 IMPLEMENTATION: Filter out options already chosen in ANY picks.
                const resolvedAnySkills = computedResults
                  .filter(r => r.type === "SKILL" && r.name.toLowerCase() !== "any" && r.name.toLowerCase() !== "any_combat")
                  .map(r => r.name.toLowerCase());
                const skillList = (anySkill === "any_combat" ? ANY_COMBAT_OPTIONS : ANY_AVAILABLE_SKILLS)
                  .filter(skill => !resolvedAnySkills.includes(skill.toLowerCase()));
                return (
                  <div key={index} style={{ margin: '10px 0' }}>
                    <p>ANY skill pick #{index + 1} ({anySkill === "any_combat" ? 'Combat skill' : 'Any skill'}):</p>
                    {skillList.map(skill => (
                      <button
                        key={skill}
                        onClick={() => handleAnySkillSelection(index, skill)}
                        style={{ margin: '5px' }}
                      >
                        {skill}
                      </button>
                    ))}
                  </div>
                );
              })}
            </div>
          )}
          {bonusResults.length > 0 && bonusResults.map((bonusRes, index) => (
            <BonusAttributeDistribution
              key={index}
              distribution={bonusRes}
              onComplete={(finalAssignment) => handleBonusDistributionComplete(index, finalAssignment)}
            />
          ))}
          <div style={{ marginTop: '20px' }}>
            <button onClick={handleConfirm}>Confirm Background Selection</button>
          </div>
        </div>
      )}
    </div>
  );
};

export default BackgroundCreation;

// STEP 3 IMPLEMENTATION: BonusAttributeDistribution component remains largely unchanged.
const BonusAttributeDistribution = ({ distribution, onComplete }) => {
  let allowedAttributes = [];
  const category = distribution.category.toUpperCase();
  if (category === "ANY") {
    allowedAttributes = ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"];
  } else if (category === "PHYSICAL") {
    allowedAttributes = ["strength", "dexterity", "constitution"];
  } else if (category === "MENTAL") {
    allowedAttributes = ["intelligence", "wisdom", "charisma"];
  }

  const initialAssignments = allowedAttributes.reduce((acc, attr) => {
    acc[attr] = 0;
    return acc;
  }, {});
  const [assignments, setAssignments] = useState(initialAssignments);
  const totalAssigned = Object.values(assignments).reduce((sum, val) => sum + Number(val), 0);
  const isComplete = totalAssigned === distribution.points;

  const handleChange = (attr, value) => {
    const numericValue = Math.max(0, parseInt(value, 10) || 0);
    setAssignments(prev => ({ ...prev, [attr]: numericValue }));
  };

  return (
    <div className="card" style={{ marginTop: '20px', padding: '10px' }}>
      <h4>
        Distribute {distribution.points} bonus point{distribution.points > 1 ? 's' : ''} for {distribution.category} attribute:
      </h4>
      {allowedAttributes.map(attr => (
        <div key={attr} style={{ marginBottom: '10px' }}>
          <label style={{ textTransform: 'capitalize' }}>
            {attr}:
            <input
              type="number"
              min="0"
              max={distribution.points}
              value={assignments[attr]}
              onChange={(e) => handleChange(attr, e.target.value)}
              style={{ marginLeft: '10px', width: '60px' }}
            />
          </label>
        </div>
      ))}
      <p>Total assigned: {totalAssigned}</p>
      {!isComplete && (
        <p style={{ color: 'red' }}>
          Please assign exactly {distribution.points} point{distribution.points > 1 ? 's' : ''}.
        </p>
      )}
      <button onClick={() => onComplete(assignments)} disabled={!isComplete}>
        Confirm Distribution
      </button>
    </div>
  );
};

export { BonusAttributeDistribution };


----- .\client\src\components\CharacterForm.js -----

// src/components/CharacterForm.js
import React, { useState } from 'react';
import api from '../services/api';

const CharacterForm = () => {
  // Rename 'name' to 'characterName' to avoid conflict with global 'name'
  const [characterName, setCharacterName] = useState('');
  const [strength, setStrength] = useState(10);
  const [dexterity, setDexterity] = useState(10);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);

  // Moved inside the component so we can access characterName, strength, and dexterity.
  const validateForm = () => {
    let errors = {};
    if (!characterName.trim()) {
      errors.characterName = 'Name is required.';
    }
    // Ensure strength and dexterity are valid numbers.
    const strValue = parseInt(strength, 10);
    const dexValue = parseInt(dexterity, 10);
    if (isNaN(strValue) || strValue < 1) {
      errors.vitals.strength = 'Strength must be a valid number.';
    }
    if (isNaN(dexValue) || dexValue < 1) {
      errors.vitals.dexterity = 'Dexterity must be a valid number.';
    }
    return errors;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);

    const validationErrors = validateForm();
    if (Object.keys(validationErrors).length > 0) {
      // Combine errors and set error state.
      setError(Object.values(validationErrors).join(' '));
      return;
    }

    try {
      await api.post('/characters/', {
        name: characterName,
        strength: parseInt(strength, 10),
        dexterity: parseInt(dexterity, 10),
      });
      console.log('Character created:', { characterName, strength, dexterity });
      setSuccess('Character created successfully!');
      setCharacterName('');
      setStrength(10);
      setDexterity(10);
    } catch (err) {
      console.error('Error creating character:', err);
      setError(err.message || 'An error occurred');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {error && <div style={{ color: 'red' }}>Error: {error}</div>}
      {success && <div style={{ color: 'green' }}>{success}</div>}
      <div>
        <label>Name</label>
        <input
          type="text"
          value={characterName}
          onChange={(e) => setCharacterName(e.target.value)}
        />
      </div>

      <div>
        <label>Strength</label>
        <input
          type="number"
          value={strength}
          onChange={(e) => setStrength(e.target.value)}
        />
      </div>

      <div>
        <label>Dexterity</label>
        <input
          type="number"
          value={dexterity}
          onChange={(e) => setDexterity(e.target.value)}
        />
      </div>

      <button type="submit">Create Character</button>
    </form>
  );
};

export default CharacterForm;


----- .\client\src\components\CharacterList.js -----

// src/components/CharacterList.js
import React, { useEffect, useState } from 'react';
import api from '../services/api';
import { Link } from 'react-router-dom';

const CharacterList = () => {
  console.log("CharacterList is mounting!");
  const [characters, setCharacters] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchCharacters();
  }, []);

  const fetchCharacters = async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await api.get('/characters/');
      console.log('Characters fetched:', response.data);
      setCharacters(response.data);
    } catch (err) {
      console.error('Failed to load characters:', err);
      if (err.response) {
        console.error('Status:', err.response.status, 'Data:', err.response.data);
      }
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return <div className="card">Loading characters...</div>;
  }

  if (error) {
    return (
      <div className="card" style={{ color: 'red' }}>
        Error fetching characters: {error.message || 'Unknown error'}
      </div>
    );
  }

  return (
    <div className="card">
      <h2>Your Characters</h2>
      {characters.length === 0 ? (
        <div>No characters found. Try creating one.</div>
      ) : (
        <ul>
          {characters.map((char) => (
            <li key={char.id}>
              <Link to={`/characters/${char.id}`}>
                {char.name} - STR: {char.vitals.strength}, DEX: {char.vitals.dexterity}
              </Link>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default CharacterList;


----- .\client\src\components\Contacts.js -----

// client/src/components/Contacts.js
import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import api from '../services/api';

const CONTACT_OPTIONS = {
  acquaintances: 2,
  friend: 1
};

const Contacts = () => {
  const navigate = useNavigate();
  const { id: characterId } = useParams(); // Assume character id is passed via URL

  // State to hold whether the user chooses "2 Acquaintances" or "1 Friend"
  const [contactOption, setContactOption] = useState('acquaintances');
  // State for the list of contacts (each with name, relationship_type, description)
  const [contacts, setContacts] = useState([]);
  // State for error messages
  const [error, setError] = useState('');

  const relationshipsMap = {
  acquaintances: 'acquaintance',
  friend: 'friend',
  };

  // Initialize contacts based on the selected option
  useEffect(() => {
  const requiredCount = CONTACT_OPTIONS[contactOption];
  const initialContacts = [];
  for (let i = 0; i < requiredCount; i++) {
    initialContacts.push({
      name: '',
      // Fix the mismatch:
      relationship_type: relationshipsMap[contactOption],
      description: ''
    });
  }
  setContacts(initialContacts);
  }, [contactOption]);

  const handleContactChange = (index, field, value) => {
    const updatedContacts = [...contacts];
    updatedContacts[index][field] = value;
    setContacts(updatedContacts);
  };

  const handleConfirm = async (e) => {
    e.preventDefault();
    setError('');

    // Validate that each contact has a non-empty name.
    for (let i = 0; i < contacts.length; i++) {
      if (!contacts[i].name.trim()) {
        setError(`Please provide a name for Contact #${i + 1}.`);
        return;
      }
    }

    // Build payload for PATCH: include contacts array and mark the contacts step complete.
    const payload = {
      contacts: contacts,
      creation_data: { contacts_completed: true }
    };

    try {
      // Send PATCH request to update the character.
      await api.patch(`/characters/${characterId}/`, payload);
      // Navigate to the next step - placeholder for Edges.
      navigate(`/characters/${characterId}/edges`);
    } catch (err) {
      console.error("Error updating contacts:", err);
      setError("There was an error saving your contacts. Please try again.");
    }
  };

  return (
    <div className="card">
      <h2>Contacts</h2>
      <p>Select how you’d like to start your contacts:</p>
      <div>
        <label>
          <input
            type="radio"
            value="acquaintances"
            checked={contactOption === 'acquaintances'}
            onChange={() => setContactOption('acquaintances')}
          />
          2 Acquaintances
        </label>
        <label style={{ marginLeft: '20px' }}>
          <input
            type="radio"
            value="friend"
            checked={contactOption === 'friend'}
            onChange={() => setContactOption('friend')}
          />
          1 Friend
        </label>
      </div>
      <hr />
      <form onSubmit={handleConfirm}>
        {contacts.map((contact, index) => (
          <div key={index} style={{ marginBottom: '15px' }}>
            <h4>Contact #{index + 1}</h4>
            <div>
              <label>
                Name:
                <input
                  type="text"
                  value={contact.name}
                  onChange={(e) => handleContactChange(index, 'name', e.target.value)}
                  required
                />
              </label>
            </div>
            <div>
              <label>
                Relationship Type:
                <input
                  type="text"
                  value={contact.relationship_type}
                  readOnly
                  style={{ marginLeft: '10px' }}
                />
              </label>
            </div>
            <div>
              <label>
                Description (optional):
                <input
                  type="text"
                  value={contact.description}
                  onChange={(e) => handleContactChange(index, 'description', e.target.value)}
                  style={{ marginLeft: '10px' }}
                />
              </label>
            </div>
          </div>
        ))}
        {error && <div style={{ color: 'red', marginBottom: '10px' }}>{error}</div>}
        <button type="submit">Confirm Contacts</button>
      </form>
      <div style={{ marginTop: '20px' }}>
        <p>Step 4 of [Total Steps]: Contacts</p>
      </div>
    </div>
  );
};

export default Contacts;


----- .\client\src\components\Edges.js -----

// client/src/components/Edges.js
import React from 'react';

const Edges = () => {
  return (
    <div className="card">
      <h2>Edges Selection (Coming Soon)</h2>
      <p>This is a placeholder for the Edges selection step in the character creation wizard.</p>
    </div>
  );
};

export default Edges;


----- .\client\src\components\EdgeSelection.js -----

// client/src/components/EdgeSelection.js
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import api from '../services/api';

const ANY_SKILL_OPTIONS = [
  "Administer", "Connect", "Drive", "Exert", "Fix", "Heal", "Know",
  "Lead", "Notice", "Perform", "Program", "Punch", "Shoot", "Sneak",
  "Stab", "Survive", "Talk", "Trade", "Work"
];

const EdgeSelection = () => {
  const { id } = useParams();  // character id
  const navigate = useNavigate();

  const [character, setCharacter] = useState(null);
  const [maxEdges, setMaxEdges] = useState(2);
  const [isUnderdog, setIsUnderdog] = useState(false);
  const [edges, setEdges] = useState([]);
  const [selectedEdges, setSelectedEdges] = useState([]);
  const [error, setError] = useState("");

  // Fetch character details and compute attribute modifier sum and underdog status
  useEffect(() => {
    const fetchCharacter = async () => {
      try {
        const res = await api.get(`/characters/${id}/`);
        const charData = res.data;
        setCharacter(charData);
        const { strength, dexterity, constitution, intelligence, wisdom, charisma } = charData;
        // Compute modifiers using (attr - 10)//2
        const modSum =
          Math.floor((strength - 10) / 2) +
          Math.floor((dexterity - 10) / 2) +
          Math.floor((constitution - 10) / 2) +
          Math.floor((intelligence - 10) / 2) +
          Math.floor((wisdom - 10) / 2) +
          Math.floor((charisma - 10) / 2);
        if (modSum <= -1) {
          setMaxEdges(3);
          setIsUnderdog(true);
        } else {
          setMaxEdges(2);
          setIsUnderdog(false);
        }
      } catch (err) {
        console.error("Error fetching character:", err);
        setError("Failed to load character data.");
      }
    };
    fetchCharacter();
  }, [id]);

  // Fetch available edges from /api/edges/
  useEffect(() => {
    const fetchEdges = async () => {
      try {
        const res = await api.get('/edges/');
        setEdges(res.data);
      } catch (err) {
        console.error("Error fetching edges:", err);
        setError("Failed to load edges.");
      }
    };
    fetchEdges();
  }, []);

  // Handler for selecting an edge
  const handleSelectEdge = (edge) => {
    // If the edge is Prodigy and the character is Underdog, forbid selection.
    if (isUnderdog && edge.name.toLowerCase() === "prodigy") {
      setError("Prodigy is not available when using the Underdog rule.");
      return;
    }
    // Check if edge is already selected
    const alreadySelected = selectedEdges.find(se => se.id === edge.id);
    if (alreadySelected) {
      if (!edge.multi_allowed) return; // if not multi_allowed, do nothing
      // Otherwise, increment rank
      setSelectedEdges(selectedEdges.map(se => {
        if (se.id === edge.id) {
          return { ...se, rank: se.rank + 1 };
        }
        return se;
      }));
      return;
    }
    if (selectedEdges.length >= maxEdges) {
      setError(`You may only select up to ${maxEdges} edges.`);
      return;
    }
    // Determine if this edge requires an ANY skill choice
    const needsSkillChoice = edge.effect_data && edge.effect_data.some(eff =>
      eff.type === "GRANT_SKILL" && (eff.skill_name === "ANY" || eff.skill_name === "ANY_COMBAT")
    );
    const newEdge = { id: edge.id, name: edge.name, rank: 1, needsSkillChoice, any_skill_choice: "" };
    setSelectedEdges([...selectedEdges, newEdge]);
    setError("");
  };

  // Handler to remove a selected edge
  const handleRemoveEdge = (edgeId) => {
    setSelectedEdges(selectedEdges.filter(se => se.id !== edgeId));
  };

  // Handler to set the ANY skill choice for a selected edge
  const handleAnySkillChoice = (edgeId, skillChoice) => {
    setSelectedEdges(selectedEdges.map(se => {
      if (se.id === edgeId) {
        return { ...se, any_skill_choice: skillChoice };
      }
      return se;
    }));
  };

  // Handler for confirming edge selection
  const handleConfirm = async () => {
    // Validate that for each edge that requires an ANY skill choice, a selection has been made
    for (let edge of selectedEdges) {
      if (edge.needsSkillChoice && !edge.any_skill_choice) {
        setError(`Please select a specific skill for edge "${edge.name}".`);
        return;
      }
    }
    const payload = {
      edge_selection: {
        edges: selectedEdges,  // each item: { id, rank, any_skill_choice }
        used_underdog: isUnderdog
      }
    };
    try {
      await api.patch(`/characters/${id}/`, payload);
      navigate(`/characters/${id}/foci`); // Redirect to the next step (Focus Selection)
    } catch (err) {
      console.error("Error saving edge selection:", err);
      setError("Error saving edge selection.");
    }
  };

  return (
    <div className="card">
      <h2>Edge Selection</h2>
      {character && (
        <p>
          Based on your attributes, you can choose up to {maxEdges} edge
          {maxEdges > 1 ? "s" : ""}.
        </p>
      )}
      {error && <div style={{ color: 'red' }}>{error}</div>}
      <h3>Available Edges</h3>
      <ul>
        {edges.map(edge => (
          <li key={edge.id} style={{ marginBottom: '10px' }}>
            <div>
              <strong>{edge.name}</strong> – {edge.description}
              {/* Disable selection for Prodigy if Underdog is active */}
              <button
                onClick={() => handleSelectEdge(edge)}
                style={{ marginLeft: '10px' }}
                disabled={isUnderdog && edge.name.toLowerCase() === "prodigy"}
              >
                Select
              </button>
            </div>
            {edge.usage_notes && (
              <div style={{ fontStyle: 'italic', color: '#888', marginTop: '4px' }}>
                {edge.usage_notes}
              </div>
            )}
          </li>
        ))}
      </ul>
      <h3>Selected Edges</h3>
      {selectedEdges.length === 0 ? (
        <p>No edges selected yet.</p>
      ) : (
        <ul>
          {selectedEdges.map(edge => (
            <li key={edge.id} style={{ marginBottom: '10px' }}>
              <div>
                <strong>{edge.name}</strong>{edge.rank > 1 && ` (Rank: ${edge.rank})`}
                <button onClick={() => handleRemoveEdge(edge.id)} style={{ marginLeft: '10px' }}>
                  Remove
                </button>
              </div>
              {edge.needsSkillChoice && (
                <div style={{ marginTop: '5px' }}>
                  <label>
                    Choose your bonus skill for {edge.name}:{' '}
                    <select
                      value={edge.any_skill_choice}
                      onChange={(e) => handleAnySkillChoice(edge.id, e.target.value)}
                    >
                      <option value="">Select a skill</option>
                      {ANY_SKILL_OPTIONS.map(skill => (
                        <option key={skill} value={skill}>{skill}</option>
                      ))}
                    </select>
                  </label>
                </div>
              )}
            </li>
          ))}
        </ul>
      )}
      <div style={{ marginTop: '20px' }}>
        <button onClick={handleConfirm}>Confirm Edge Selection</button>
      </div>
    </div>
  );
};

export default EdgeSelection;


----- .\client\src\components\FinalSteps.js -----

// client/src/components/FinalSteps.js
import React from 'react';
import { useParams, Link } from 'react-router-dom';

const FinalSteps = () => {
  const { id } = useParams();

  return (
    <div className="card">
      <h2>Final Character Creation Steps</h2>
      <p>
        You have finished selecting your Edges and Foci.
        <br />
        Next steps: choose your gear, finalize your character name and goal,
        and complete any remaining steps.
      </p>
      <p>
        When you're ready, you can view your character summary:{" "}
        <Link to={`/characters/${id}`}>View Character</Link>
      </p>
      <p>
        (This page is a placeholder and will be expanded in the future.)
      </p>
    </div>
  );
};

export default FinalSteps;


----- .\client\src\components\FocusSelection.js -----

// client/src/components/FocusSelection.js

import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import api from '../services/api';

const FocusSelection = () => {
  const { id } = useParams();
  const navigate = useNavigate();

  const [availableFoci, setAvailableFoci] = useState([]);
  const [selectedFoci, setSelectedFoci] = useState([]);
  const [allowedFocusCount, setAllowedFocusCount] = useState(1);
  const [character, setCharacter] = useState(null);
  const [error, setError] = useState("");

  // Fetch available foci from /api/foci/
  useEffect(() => {
    const fetchFoci = async () => {
      try {
        const res = await api.get('/foci/');
        setAvailableFoci(res.data);
      } catch (err) {
        console.error("Error fetching foci:", err);
        setError("Failed to load foci.");
      }
    };
    fetchFoci();
  }, []);

  // Fetch character details to determine allowed focus count.
  useEffect(() => {
    const fetchCharacter = async () => {
      try {
        const res = await api.get(`/characters/${id}/`);
        setCharacter(res.data);
        // If any edge has the name "Focused", allow 2 foci; otherwise, allow 1.
        const focusedEdge = res.data.character_edges.find(
          (edge) => edge.edge.name.toLowerCase() === "focused"
        );
        setAllowedFocusCount(focusedEdge ? 2 : 1);
      } catch (err) {
        console.error("Error fetching character:", err);
        setError("Failed to load character data.");
      }
    };
    fetchCharacter();
  }, [id]);

  // Handler for selecting a focus from the available list
  const handleSelectFocus = (focus) => {
    // If the focus is not multi_allowed and already selected, prevent duplicates.
    if (!focus.multi_allowed && selectedFoci.find(sf => sf.id === focus.id)) {
      setError(`You have already selected ${focus.name}.`);
      return;
    }
    if (selectedFoci.length >= allowedFocusCount) {
      setError(`You may only select up to ${allowedFocusCount} focus${allowedFocusCount > 1 ? 'es' : ''}.`);
      return;
    }
    // Default rank is 1; allow the user to adjust later.
    const newSelection = {
      id: focus.id,
      name: focus.name,
      rank: 1,
      chosen_skill: ""
    };
    setSelectedFoci([...selectedFoci, newSelection]);
    setError("");
  };

  // Handler for removing a selected focus
  const handleRemoveFocus = (focusId, index) => {
    const updated = [...selectedFoci];
    updated.splice(index, 1);
    setSelectedFoci(updated);
  };

  // Handler to update the rank for a selected focus
  const handleRankChange = (index, newRank) => {
    const updated = [...selectedFoci];
    updated[index].rank = parseInt(newRank, 10);
    setSelectedFoci(updated);
  };

  // Handler for updating chosen skill (if required) for a selected focus
  const handleChosenSkillChange = (index, chosenSkill) => {
    const updated = [...selectedFoci];
    updated[index].chosen_skill = chosenSkill;
    setSelectedFoci(updated);
  };

  // Toggle display of level details for each available focus.
  const [expandedFocus, setExpandedFocus] = useState({});
  const toggleFocusDetails = (focusId) => {
    setExpandedFocus(prev => ({
      ...prev,
      [focusId]: !prev[focusId]
    }));
  };

  // Available skills list for Focuses that require a chosen skill (e.g., "Specialist")
  const availableSkills = [
    "Administer", "Connect", "Drive", "Exert", "Fix", "Heal",
    "Know", "Lead", "Notice", "Perform", "Program", "Punch",
    "Shoot", "Sneak", "Stab", "Survive", "Talk", "Trade", "Work"
  ];

  // On confirm, build payload and PATCH to /api/characters/:id/
  const handleConfirm = async () => {
    if (selectedFoci.length === 0) {
      setError("Please select at least one focus.");
      return;
    }
    // (Additional validation can be added here as needed.)
    const payload = {
      focus_selection: {
        foci: selectedFoci.map(focus => ({
          id: focus.id,
          rank: focus.rank,
          chosen_skill: focus.chosen_skill || null
        }))
      }
    };
    try {
      await api.patch(`/characters/${id}/`, payload);
      navigate(`/characters/${id}/final`);
    } catch (err) {
      console.error("Error saving focus selection:", err);
      setError("Error saving focus selection.");
    }
  };

  return (
    <div className="card">
      <h2>Focus Selection</h2>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      <p>You may select up to {allowedFocusCount} focus{allowedFocusCount > 1 ? 'es' : ''}.</p>

      <h3>Available Foci</h3>
      <ul>
        {availableFoci.map(focus => (
          <li key={focus.id} style={{ marginBottom: '15px', borderBottom: '1px solid #ccc', paddingBottom: '10px' }}>
            <strong>{focus.name}</strong> (Max Level: {focus.max_level})<br />
            <span>{focus.description}</span><br />
            <button onClick={() => toggleFocusDetails(focus.id)} style={{ marginRight: '10px' }}>
              {expandedFocus[focus.id] ? "Hide Levels" : "View Levels"}
            </button>
            <button onClick={() => handleSelectFocus(focus)}>
              Select
            </button>
            {expandedFocus[focus.id] && focus.levels && (
              <div style={{ marginTop: '10px', paddingLeft: '10px', fontStyle: 'italic' }}>
                {focus.levels.map(level => (
                  <div key={level.level}>
                    <strong>Level {level.level}:</strong> {level.summary}
                  </div>
                ))}
              </div>
            )}
          </li>
        ))}
      </ul>

      <h3>Selected Foci</h3>
      {selectedFoci.length === 0 ? (
        <p>No foci selected yet.</p>
      ) : (
        <ul>
          {selectedFoci.map((sf, index) => (
            <li key={index} style={{ marginBottom: '10px' }}>
              <strong>{sf.name}</strong> – Rank:&nbsp;
              <select value={sf.rank} onChange={(e) => handleRankChange(index, e.target.value)}>
                {Array.from({ length: availableFoci.find(f => f.id === sf.id)?.max_level || 1 }, (_, i) => i + 1).map(r => (
                  <option key={r} value={r}>{r}</option>
                ))}
              </select>
              {/* If this focus requires a chosen skill, e.g., if its name is "Specialist" */}
              {sf.name.toLowerCase() === "specialist" && (
                <span>
                  &nbsp;|&nbsp; Choose Skill:&nbsp;
                  <select value={sf.chosen_skill} onChange={(e) => handleChosenSkillChange(index, e.target.value)}>
                    <option value="">Select a skill</option>
                    {availableSkills.map(skill => (
                      <option key={skill} value={skill}>{skill}</option>
                    ))}
                  </select>
                </span>
              )}
              <button onClick={() => handleRemoveFocus(sf.id, index)} style={{ marginLeft: '10px' }}>
                Remove
              </button>
            </li>
          ))}
        </ul>
      )}

      <div style={{ marginTop: '20px' }}>
        <button onClick={handleConfirm}>Confirm Focus Selection</button>
      </div>
    </div>
  );
};

export default FocusSelection;


----- .\client\src\components\Home.js -----

import React from 'react';

const Home = () => {
  return (
    <div className="card">
      <h2>Welcome Home!</h2>
      <p>
        This is your dashboard. More features (blog posts, campaign updates, etc.) will appear here soon.
      </p>
    </div>
  );
};

export default Home;


----- .\client\src\components\Layout.js -----

import React, { useContext } from 'react';
import { Outlet, Link } from 'react-router-dom';
import styled, { ThemeProvider } from 'styled-components';
import { AuthContext } from '../contexts/AuthContext';

// Define your theme colors (you can adjust these to match your cyberpunk aesthetic)
const theme = {
  primary: '#0fffc1', // bright cyan accent
  background: '#282c34', // dark background
  text: '#ffffff', // white text
  hover: '#ff2079', // a hot pink for hover effects
};

// Create styled components for the navigation bar
const NavBar = styled.nav`
  background-color: ${props => props.theme.background};
  padding: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
`;

const NavLink = styled(Link)`
  color: ${props => props.theme.primary};
  margin: 0 10px;
  text-decoration: none;
  font-weight: bold;
  transition: color 0.3s ease;

  &:hover {
    color: ${props => props.theme.hover};
  }
`;

const LogoutButton = styled.button`
  background: none;
  border: none;
  color: ${props => props.theme.primary};
  font-weight: bold;
  cursor: pointer;
  transition: color 0.3s ease;
  margin: 0 10px;

  &:hover {
    color: ${props => props.theme.hover};
  }
`;

const LayoutContainer = styled.div`
  min-height: 100vh;
  background-color: ${props => props.theme.background};
  color: ${props => props.theme.text};
`;

const Layout = () => {
  const { token, handleLogout } = useContext(AuthContext);

  return (
    <ThemeProvider theme={theme}>
      <LayoutContainer>
        <NavBar>
          {token ? (
            <>
              <NavLink to="/home">Home</NavLink>
              <NavLink to="/characters">Characters</NavLink>
              <NavLink to="/new">New Character</NavLink>
              <LogoutButton onClick={handleLogout}>Logout</LogoutButton>
            </>
          ) : (
            <>
              <NavLink to="/welcome">Welcome</NavLink>
              <NavLink to="/login">Login</NavLink>
              <NavLink to="/register">Register</NavLink>
            </>
          )}
        </NavBar>
        <Outlet />
      </LayoutContainer>
    </ThemeProvider>
  );
};

export default Layout;


----- .\client\src\components\Login.js -----

// src/components/Login.js
import React, { useState, useContext } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../services/api';
import { AuthContext } from '../contexts/AuthContext';

function Login({ setToken }) {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState(null);
  const { handleLogin } = useContext(AuthContext);
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);

    if (!username.trim() || !password.trim()) {
      setError('Both username and password are required.');
      return;
    }

    try {
      const response = await api.post('/token/', { username, password });
      const { access, refresh } = response.data;
      localStorage.setItem('accessToken', access);
      localStorage.setItem('refreshToken', refresh);
      handleLogin(access);
      navigate('/home');
    } catch (err) {
      console.error('Login error:', err);
      setError('Invalid username/password');
    }
  };

  return (
    <div>
      <h2>Login</h2>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      <form onSubmit={handleSubmit}>
        <div>
          <label>Username: </label>
          <input
            type="text"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
          />
        </div>
        <div>
          <label>Password: </label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
        </div>
        <button type="submit">Log In</button>
      </form>
    </div>
  );
}

export default Login;


----- .\client\src\components\NewCharacterChoice.js -----

import React from 'react';
import { Link } from 'react-router-dom';

const NewCharacterChoice = () => {
  return (
    <div className="card">
      <h2>Create a New Character</h2>
      <p>Choose how you'd like to create your character:</p>

      <div style={{ marginTop: '20px' }}>
        <Link to="/new/discover" style={{ marginRight: '20px' }}>
          <button>Discover a New Character</button>
        </Link>

        <Link to="/new/manual">
          <button>Describe an Existing Character</button>
        </Link>
      </div>
    </div>
  );
};

export default NewCharacterChoice;


----- .\client\src\components\ProtectedRoute.js -----

// ./client/src/components/ProtectedRoute.js

import React, { useContext } from 'react';
import { Navigate } from 'react-router-dom';
import { AuthContext } from '../contexts/AuthContext';

const ProtectedRoute = ({ children }) => {
  const { token } = useContext(AuthContext);

  if (!token) {
    return <Navigate to="/welcome" replace />;
  }
  return children;
};

export default ProtectedRoute;


----- .\client\src\components\Register.js -----

import React, { useState, useContext } from 'react';
import { AuthContext } from '../contexts/AuthContext';
import { useNavigate } from 'react-router-dom';
import api from '../services/api';

function Register() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [email, setEmail] = useState('');
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);
  const navigate = useNavigate();
  const { handleLogin } = useContext(AuthContext);
  const validateRegister = () => {
    let errors = {};

    if (!username.trim()) {
      errors.username = 'Username is required.';
    }
    if (!password.trim()) {
      errors.password = 'Password is required.';
    }
    if (!email.trim()) {
      errors.email = 'Email is required.';
    } else {
      // Simple email regex check
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        errors.email = 'Email format is invalid.';
      }
    }
    return errors;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);
    setSuccess(null);

    const validationErrors = validateRegister();
    if (Object.keys(validationErrors).length > 0) {
      setError(Object.values(validationErrors).join(' '));
      return;
    }

    try {
      await api.post('/register/', { username, password, email });
      const loginResponse = await api.post('/token/', { username, password });
      localStorage.setItem('accessToken', loginResponse.data.access);
      localStorage.setItem('refreshToken', loginResponse.data.refresh);
      handleLogin(loginResponse.data.access);
      navigate('/home');;
    } catch (err) {
      console.error('Registration error:', err.response.data);
      setError('Registration failed.');
    }
  };

  return (
    <div>
      <h2>Register</h2>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      {success && <div style={{ color: 'green' }}>{success}</div>}
      <form onSubmit={handleSubmit}>
        <div>
          <label>Username:</label>
          <input
            type="text"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
          />
        </div>
        <div>
          <label>Password:</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
        </div>
        <div>
          <label>Email:</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
        </div>
        <button type="submit">Sign Up</button>
      </form>
    </div>
  );
}

export default Register;


----- .\client\src\components\ViewCharacter.js -----

import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import api from '../services/api';

const ViewCharacter = () => {
  const { id } = useParams();
  const [character, setCharacter] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchCharacter = async () => {
      try {
        const response = await api.get(`/characters/${id}/`);
        setCharacter(response.data);
      } catch (err) {
        console.error('Error fetching character:', err);
        setError('Could not fetch character.');
      } finally {
        setLoading(false);
      }
    };
    fetchCharacter();
  }, [id]);

  if (loading) return <div>Loading character details...</div>;
  if (error) return <div style={{ color: 'red' }}>{error}</div>;
  if (!character) return <div>No character found.</div>;

  // Extract vitals (if available) and assign defaults
  const vitals = character.vitals || {};
  const {
    strength,
    dexterity,
    constitution,
    intelligence,
    wisdom,
    charisma,
    current_hp,
    max_hp,
    attack_bonus_base,
    base_ac,
    system_strain_current,
    system_strain_max,
    trauma_target,
    save_physical,
    save_evasion,
    save_mental,
    save_luck,
  } = vitals;

  return (
    <div className="card">
      <h2>{character.name}</h2>

      <h3>Background</h3>
      {character.background ? (
        <div>
          <p>
            <strong>{character.background.name}</strong>
          </p>
          <p>{character.background.description}</p>
        </div>
      ) : (
        <p>No background selected.</p>
      )}

      <h3>Vitals</h3>
      <ul>
        <li>
          <strong>HP:</strong> {current_hp} / {max_hp}
        </li>
        <li>
          <strong>Base AC:</strong> {base_ac}
        </li>
        <li>
          <strong>Attack Bonus (Base):</strong> {attack_bonus_base}
        </li>
        <li>
          <strong>System Strain:</strong> {system_strain_current} / {system_strain_max}
        </li>
        <li>
          <strong>Trauma Target:</strong> {trauma_target}
        </li>
      </ul>

      <h3>Attributes</h3>
      <ul>
        <li>Strength: {strength}</li>
        <li>Dexterity: {dexterity}</li>
        <li>Constitution: {constitution}</li>
        <li>Intelligence: {intelligence}</li>
        <li>Wisdom: {wisdom}</li>
        <li>Charisma: {charisma}</li>
      </ul>

      <h3>Saving Throws</h3>
      <ul>
        <li>Physical: {save_physical}</li>
        <li>Evasion: {save_evasion}</li>
        <li>Mental: {save_mental}</li>
        <li>Luck: {save_luck}</li>
      </ul>

      <h3>Acquired Skills</h3>
      {character.skills && character.skills.length > 0 ? (
        <ul>
          {character.skills.map((cs, index) => {
            // Ensure we display the nested skill's name
            const skillName = cs.skill && cs.skill.name ? cs.skill.name : "Unknown Skill";
            return (
              <li key={index}>
                <strong>{skillName}</strong> – Level: {cs.level}
              </li>
            );
          })}
        </ul>
      ) : (
        <p>No skills acquired yet.</p>
      )}

      <h3>Edges</h3>
      {character.character_edges && character.character_edges.length > 0 ? (
        <ul>
          {character.character_edges.map((ce, index) => {
            const edgeName = ce.edge && ce.edge.name ? ce.edge.name : "Unknown Edge";
            const edgeDesc = ce.edge && ce.edge.description ? ce.edge.description : "";
            return (
              <li key={index}>
                <strong>{edgeName}</strong> – {edgeDesc}
                {ce.rank > 1 && ` (Rank: ${ce.rank})`}
              </li>
            );
          })}
        </ul>
      ) : (
        <p>No edges selected.</p>
      )}

      <h3>Foci</h3>
      {character.character_focuses && character.character_focuses.length > 0 ? (
        <ul>
          {character.character_focuses.map((cf, index) => {
            const focusName = cf.focus && cf.focus.name ? cf.focus.name : "Unknown Focus";
            return (
              <li key={index}>
                <strong>{focusName}</strong> – Rank: {cf.rank}
                {cf.chosen_skill && ` (Specialty: ${cf.chosen_skill})`}
                {cf.usage_data && (
                  <div style={{ fontStyle: 'italic', fontSize: '0.9em' }}>
                    Usage Data: {JSON.stringify(cf.usage_data)}
                  </div>
                )}
              </li>
            );
          })}
        </ul>
      ) : (
        <p>No foci selected yet.</p>
      )}

      <h3>Contacts</h3>
      {character.contacts && character.contacts.length > 0 ? (
        <ul>
          {character.contacts.map((contact) => (
            <li key={contact.id}>
              <strong>{contact.name}</strong> ({contact.relationship_type}) – {contact.description}
            </li>
          ))}
        </ul>
      ) : (
        <p>No contacts have been added yet.</p>
      )}
    </div>
  );
};

export default ViewCharacter;


----- .\client\src\components\Welcome.js -----

import React from 'react';
import { Link } from 'react-router-dom';

const Welcome = () => {
  return (
    <div className="card">
      <h2>Welcome to [Your App Name]</h2>
      <p>
        Discover a platform where you can manage your characters, follow campaign updates, and read blog posts about our adventures.
      </p>
      <p>
        Please <Link to="/login">log in</Link> or <Link to="/register">register</Link> to get started.
      </p>
    </div>
  );
};

export default Welcome;


----- .\client\src\contexts\AuthContext.js -----

// ./client/src/contexts/AuthContext.js

import React, { createContext, useState } from 'react';

export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [token, setToken] = useState(localStorage.getItem('accessToken'));

  const handleLogin = (newToken) => {
    localStorage.setItem('accessToken', newToken);
    setToken(newToken);
  };

  const handleLogout = () => {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
    setToken(null);
    window.location.href = '/welcome';
  };

  return (
    <AuthContext.Provider value={{ token, setToken, handleLogin, handleLogout }}>
      {children}
    </AuthContext.Provider>
  );
};


----- .\client\src\hooks\useUserRoles.js -----

// client/src/hooks/useUserRoles.js

import { useState, useEffect } from 'react';
import axios from 'axios';

const useUserRoles = () => {
  const [roles, setRoles] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    axios.get('/api/user_roles/')
      .then(res => {
        setRoles(res.data.roles);
        setLoading(false);
      })
      .catch(err => {
        console.error("Error fetching user roles:", err);
        setLoading(false);
      });
  }, []);

  return { roles, loading };
};

export default useUserRoles;


----- .\client\src\services\api.js -----

// src/services/api.js
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://127.0.0.1:8000/api/',
  withCredentials: true,
});

// Request interceptor to attach the access token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor to refresh JWT token proactively
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // Check if error response is 401 (unauthorized) and retry flag is not set
    if (error.response && error.response.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      try {
        // Get the refresh token from localStorage
        const refreshToken = localStorage.getItem('refreshToken');
        if (refreshToken) {
          // Make a call to the refresh endpoint using a separate axios instance to avoid interceptors
          const { data } = await axios.post(
            'http://127.0.0.1:8000/api/token/refresh/',
            { refresh: refreshToken }
          );
          // Update localStorage with the new access token
          localStorage.setItem('accessToken', data.access);
          // Update the original request's authorization header
          originalRequest.headers.Authorization = `Bearer ${data.access}`;
          // Retry the original request with the new token
          return api(originalRequest);
        }
      } catch (refreshError) {
        // Optionally, clear tokens and redirect to login if refresh fails
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        window.location = '/login';
        return Promise.reject(refreshError);
      }
    }
    return Promise.reject(error);
  }
);

export default api;


----- .\server\manage.py -----

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'venture.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


----- .\server\characters\admin.py -----

# server/characters/admin.py
from django.contrib import admin
from .models import Background, Skill, Contact

admin.site.register(Background)
admin.site.register(Skill)
admin.site.register(Contact)

----- .\server\characters\apps.py -----

from django.apps import AppConfig


class CharactersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'characters'

    def ready(self):
        import characters.signals


----- .\server\characters\models.py -----

from django.db import models
from django.contrib.auth.models import User
from django.db.models import JSONField


class Background(models.Model):
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)
    free_skill = models.CharField(max_length=50)
    is_default = models.BooleanField(default=False)
    version = models.CharField(max_length=20, default="1.0.0")
    growth_table = JSONField(blank=True, null=True)
    learning_table = JSONField(blank=True, null=True)
    manual_table = JSONField(blank=True, null=True)

    def __str__(self):
        return self.name


class Edge(models.Model):
    # Basic identification
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)

    # Category for filtering (e.g., COMMON, MAGICAL)
    EDGE_CATEGORY_CHOICES = [
        ('COMMON', 'Common'),
        ('MAGICAL', 'Magical'),
    ]
    category = models.CharField(max_length=20, choices=EDGE_CATEGORY_CHOICES, default='COMMON')

    # Whether the edge can be chosen multiple times
    multi_allowed = models.BooleanField(default=False)

    # Prerequisites as a JSON field (e.g., {"no_underdog": true})
    prerequisites = JSONField(blank=True, null=True)

    # The mechanical effects defined as JSON
    effect_data = JSONField(blank=True, null=True)

    # A text field for usage notes (e.g., "Once per scene, ...")
    usage_notes = models.TextField(blank=True)

    # NEW: Source field to indicate where the edge comes from.
    source = models.CharField(max_length=100, blank=True)

    def __str__(self):
        return self.name


class CharacterEdge(models.Model):
    character = models.ForeignKey('Character', on_delete=models.CASCADE, related_name='character_edges')
    edge = models.ForeignKey(Edge, on_delete=models.CASCADE, related_name='character_edges')
    # Track if an edge is taken more than once (e.g., Focused)
    rank = models.PositiveSmallIntegerField(default=1)
    # For future ephemeral usage tracking (e.g., usage counters)
    usage_data = JSONField(blank=True, null=True)

    def __str__(self):
        return f"{self.character.name} - {self.edge.name} (Rank {self.rank})"


class Skill(models.Model):
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)
    category = models.CharField(max_length=50, blank=True)
    default_modifier = models.IntegerField(default=-1)

    def __str__(self):
        return self.name


class Character(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='characters')
    name = models.CharField(max_length=100)
    goal = models.CharField(max_length=255, blank=True)

    # These attributes will be moved to the CharacterVitals model.
    # Comment them out for now to avoid duplication:
    # strength = models.PositiveIntegerField(default=10)
    # dexterity = models.PositiveIntegerField(default=10)
    # constitution = models.PositiveIntegerField(default=10)
    # intelligence = models.PositiveIntegerField(default=10)
    # wisdom = models.PositiveIntegerField(default=10)
    # charisma = models.PositiveIntegerField(default=10)

    # Flag to determine if character creation is complete.
    is_complete = models.BooleanField(default=False)
    # Field to store in-progress creation data (for returning to the wizard).
    creation_data = JSONField(blank=True, null=True)

    # Relationships with other character-creation components.
    background = models.ForeignKey(Background, on_delete=models.SET_NULL,
                                   null=True, blank=True, related_name='characters')
    edge = models.ManyToManyField(Edge, blank=True, related_name='characters')
    skills = models.ManyToManyField(Skill, through='CharacterSkill', blank=True, related_name='characters')
    focus = models.ManyToManyField("Focus", through="CharacterFocus", blank=True, related_name="characters")

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.name} ({self.user.username})"

    def contact_list(self):
        return self.contacts.all()


class CharacterVitals(models.Model):
    character = models.OneToOneField(Character, on_delete=models.CASCADE, related_name='vitals')

    # Universal Stats
    current_hp = models.PositiveIntegerField(default=0)
    max_hp = models.PositiveIntegerField(default=0)
    attack_bonus_base = models.IntegerField(default=0)
    base_ac = models.IntegerField(default=0)
    save_physical = models.IntegerField(default=0)
    save_evasion = models.IntegerField(default=0)
    save_mental = models.IntegerField(default=0)
    save_luck = models.IntegerField(default=0)
    is_frail = models.BooleanField(default=False)
    is_mortally_wounded = models.BooleanField(default=False)

    # Moved Attributes (for easier modification later)
    strength = models.PositiveIntegerField(default=10)
    dexterity = models.PositiveIntegerField(default=10)
    constitution = models.PositiveIntegerField(default=10)
    intelligence = models.PositiveIntegerField(default=10)
    wisdom = models.PositiveIntegerField(default=10)
    charisma = models.PositiveIntegerField(default=10)

    # CWn-Specific Fields
    system_strain_current = models.IntegerField(default=0)
    system_strain_max = models.IntegerField(default=0)
    trauma_target = models.IntegerField(default=6)
    major_injuries = JSONField(blank=True, null=True)

    def __str__(self):
        return f"{self.character.name}'s Vitals"

class CharacterSkill(models.Model):
    character = models.ForeignKey(Character, on_delete=models.CASCADE)
    skill = models.ForeignKey(Skill, on_delete=models.CASCADE)
    # 'level' represents the invested points.
    # A character with no investment (no record) is treated as -1 by default.
    # When a record exists with level=0, that is considered "Skill: Level-0" (effective modifier 0),
    # level=1 means "Skill: Level-1" (effective modifier +1), etc.
    level = models.PositiveSmallIntegerField(default=0)

    class Meta:
        unique_together = ('character', 'skill')

    def __str__(self):
        return f"{self.character.name} - {self.skill.name} (Level {self.level})"

    @property
    def effective_modifier(self):
        return self.level


class Modifier(models.Model):
    MODIFIER_TYPE_CHOICES = [
        ('ATTRIBUTE', 'Attribute'),
        ('SKILL', 'Skill'),
    ]
    source = models.CharField(max_length=50)
    source_id = models.IntegerField()
    modifier_type = models.CharField(max_length=20, choices=MODIFIER_TYPE_CHOICES)
    category = models.CharField(max_length=20, blank=True, null=True)
    skill_name = models.CharField(max_length=50, blank=True, null=True)
    points = models.IntegerField(default=0)

    def __str__(self):
        return f"{self.source} (ID: {self.source_id}) - {self.modifier_type}: {self.points}"


class Contact(models.Model):
    RELATIONSHIP_CHOICES = [
        ('acquaintance', 'Acquaintance'),
        ('friend', 'Friend'),
    ]
    character = models.ForeignKey(Character, on_delete=models.CASCADE, related_name='contacts')
    name = models.CharField(max_length=100)
    relationship_type = models.CharField(max_length=20, choices=RELATIONSHIP_CHOICES)
    description = models.TextField(blank=True)

    def __str__(self):
        return f"{self.name} ({self.get_relationship_type_display()})"


class Focus(models.Model):
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)
    version = models.CharField(max_length=20, default="1.0.0")
    category = models.CharField(max_length=20, default="COMMON")
    source = models.CharField(max_length=100, blank=True)
    max_level = models.PositiveSmallIntegerField(default=2)
    multi_allowed = models.BooleanField(default=False)
    prerequisites = JSONField(blank=True, null=True)
    usage_notes = models.TextField(blank=True)
    levels = JSONField(blank=True, null=True)

    def __str__(self):
        return self.name


class CharacterFocus(models.Model):
    character = models.ForeignKey(Character, on_delete=models.CASCADE, related_name='character_focuses')
    focus = models.ForeignKey(Focus, on_delete=models.CASCADE, related_name='character_focuses')
    rank = models.PositiveSmallIntegerField(default=1)
    chosen_skill = models.CharField(max_length=50, blank=True, null=True)
    usage_data = JSONField(blank=True, null=True)

    def __str__(self):
        return f"{self.character.name} - {self.focus.name} (Rank {self.rank})"


----- .\server\characters\serializers.py -----

from rest_framework import serializers
from .models import (
    Character, CharacterSkill, Skill, Background, Contact, Edge,
    CharacterEdge, Focus, CharacterFocus, CharacterVitals
)

class FocusSerializer(serializers.ModelSerializer):
    class Meta:
        model = Focus
        fields = '__all__'


class CharacterFocusSerializer(serializers.ModelSerializer):
    focus = FocusSerializer(read_only=True)

    class Meta:
        model = CharacterFocus
        fields = ['focus', 'rank', 'chosen_skill', 'usage_data']


class ContactSerializer(serializers.ModelSerializer):
    class Meta:
        model = Contact
        fields = ['id', 'name', 'relationship_type', 'description']

class SkillSerializer(serializers.ModelSerializer):
    class Meta:
        model = Skill
        fields = ['id', 'name', 'description', 'category', 'default_modifier']

class CharacterSkillSerializer(serializers.ModelSerializer):
    skill = SkillSerializer(read_only=True)
    effective_modifier = serializers.IntegerField()

    class Meta:
        model = CharacterSkill
        fields = ['skill', 'level', 'effective_modifier']


class EdgeSerializer(serializers.ModelSerializer):
    class Meta:
        model = Edge
        fields = '__all__'


class CharacterEdgeSerializer(serializers.ModelSerializer):
    edge = EdgeSerializer(read_only=True)

    class Meta:
        model = CharacterEdge
        fields = ['edge', 'rank', 'usage_data']


class BackgroundSerializer(serializers.ModelSerializer):
    class Meta:
        model = Background
        fields = '__all__'

class CharacterVitalsSerializer(serializers.ModelSerializer):
    class Meta:
        model = CharacterVitals
        fields = [
            'strength', 'dexterity', 'constitution', 'intelligence', 'wisdom', 'charisma',
            'current_hp', 'max_hp',
            'attack_bonus_base', 'base_ac',
            'save_physical', 'save_evasion', 'save_mental', 'save_luck',
            'is_frail', 'is_mortally_wounded',
            'system_strain_current', 'system_strain_max',
            'trauma_target', 'major_injuries',
        ]
        # By default, partial updates are allowed if we call patch() with "partial=True"


class CharacterSerializer(serializers.ModelSerializer):
    skills = CharacterSkillSerializer(source='characterskill_set', many=True, read_only=True)
    contacts = ContactSerializer(many=True, required=False)
    character_edges = CharacterEdgeSerializer(many=True, read_only=True)
    character_focuses = CharacterFocusSerializer(many=True, read_only=True)
    # Make vitals writable
    vitals = CharacterVitalsSerializer(required=False)

    class Meta:
        model = Character
        fields = '__all__'
        read_only_fields = ['user', 'created_at', 'updated_at']

    def update(self, instance, validated_data):
        # Handle nested Vitals
        vitals_data = validated_data.pop('vitals', None)
        if vitals_data is not None:
            # Partial update for nested model
            vitals_serializer = CharacterVitalsSerializer(
                instance=instance.vitals,
                data=vitals_data,
                partial=True
            )
            vitals_serializer.is_valid(raise_exception=True)
            vitals_serializer.save()

        # Handle contacts (unchanged)
        contacts_data = validated_data.pop('contacts', None)
        instance = super().update(instance, validated_data)
        if contacts_data is not None:
            instance.contacts.all().delete()
            for contact_data in contacts_data:
                Contact.objects.create(character=instance, **contact_data)
            creation_data = instance.creation_data or {}
            creation_data['contacts_completed'] = True
            instance.creation_data = creation_data

        instance.save()
        return instance


# Duplicated FocusSerializer (not strictly needed, but left if your code references it)
class FocusSerializer(serializers.ModelSerializer):
    class Meta:
        model = Focus
        fields = '__all__'


----- .\server\characters\signals.py -----

from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import Character, CharacterVitals

@receiver(post_save, sender=Character)
def create_or_update_character_vitals(sender, instance, created, **kwargs):
    if created:
        # Create a CharacterVitals instance with default values.
        # Set current_hp and max_hp to 1 (as a baseline).
        CharacterVitals.objects.create(
            character=instance,
            current_hp=1,
            max_hp=1,
            attack_bonus_base=0,
            base_ac=0,
            save_physical=0,
            save_evasion=0,
            save_mental=0,
            save_luck=0,
            is_frail=False,
            is_mortally_wounded=False,
            strength=10,
            dexterity=10,
            constitution=10,
            intelligence=10,
            wisdom=10,
            charisma=10,
            system_strain_current=0,
            system_strain_max=0,
            trauma_target=6,
            major_injuries=None  # or {} if you prefer an empty dict
        )
    else:
        # Optionally, you can update the vitals here if needed.
        # For now, we simply save the existing vitals to ensure any signals
        # connected with it are triggered.
        if hasattr(instance, 'vitals'):
            instance.vitals.save()


----- .\server\characters\tests.py -----

from django.test import TestCase

# Create your tests here.


----- .\server\characters\views.py -----

from rest_framework import viewsets, permissions, serializers
from rest_framework.response import Response
from .models import Character, Background, Skill, CharacterSkill, Contact, Edge, CharacterEdge, Focus, CharacterFocus
from .serializers import CharacterSerializer,BackgroundSerializer,SkillSerializer, ContactSerializer, EdgeSerializer, FocusSerializer
from .services.modifiers import apply_modifiers
from .services.foci import apply_focus_selection



def apply_focus_selection(character, focus_selection):
    """
    Applies the chosen focus selection to the given character.
    Expects focus_selection to be a dict with a "foci" key containing a list of objects:
      { "id": <focus_id>, "rank": <chosen_rank>, "chosen_skill": <optional> }
    """
    # Clear any existing CharacterFocus entries for this character.
    character.character_focuses.all().delete()

    foci_list = focus_selection.get("foci", [])
    if not foci_list:
        raise serializers.ValidationError("No foci provided in focus_selection.")

    # Initialize a log for any ephemeral focus effects (not fully implemented yet)
    creation_data = character.creation_data or {}
    focus_ephemeral = creation_data.get('focus_ephemeral', [])

    for focus_item in foci_list:
        focus_id = focus_item.get("id")
        rank = focus_item.get("rank", 1)
        chosen_skill = focus_item.get("chosen_skill")  # optional

        try:
            focus_obj = Focus.objects.get(id=focus_id)
        except Focus.DoesNotExist:
            raise serializers.ValidationError(f"Focus with id {focus_id} does not exist.")

        # Validate chosen rank does not exceed max_level.
        if rank > focus_obj.max_level:
            raise serializers.ValidationError(
                f"Focus '{focus_obj.name}' cannot be taken at rank {rank} (max level: {focus_obj.max_level})."
            )

        # Create a pivot record in CharacterFocus.
        CharacterFocus.objects.create(
            character=character,
            focus=focus_obj,
            rank=rank,
            chosen_skill=chosen_skill
        )

        # Process immediate effects from this focus's levels.
        levels_data = focus_obj.levels or []
        for level_entry in levels_data:
            if level_entry.get("level", 0) <= rank:
                for effect in level_entry.get("effect_data", []):
                    effect_type = effect.get("type")
                    if effect_type == "GRANT_SKILL":
                        skill_name = effect.get("skill_name")
                        bonus_points = effect.get("points", 0)
                        # Retrieve the skill object (case-insensitive match)
                        try:
                            skill_obj = Skill.objects.get(name__iexact=skill_name)
                        except Skill.DoesNotExist:
                            # Skip if the skill doesn't exist.
                            continue
                        # Enforce creation rule: maximum skill level is 1.
                        cs = CharacterSkill.objects.filter(character=character, skill=skill_obj).first()
                        if cs is None:
                            # If bonus_points is given and at least 1, set level to 1.
                            level = 1 if bonus_points >= 1 else 0
                            CharacterSkill.objects.create(character=character, skill=skill_obj, level=level)
                        else:
                            # If already exists and below 1, upgrade to level 1 if bonus applies.
                            if cs.level < 1 and bonus_points >= 1:
                                cs.level = 1
                                cs.save()
                        # Optionally, you could log if bonus_points exceed what can be applied.
                    elif effect_type == "ATTRIBUTE_MOD":
                        # Example: Modify a specific attribute if not generic.
                        attribute = effect.get("attribute", "").upper()
                        amount = effect.get("amount", 0)
                        if attribute == "STRENGTH":
                            character.vitals.strength = min(character.vitals.strength + amount, 18)
                        elif attribute == "DEXTERITY":
                            character.vitals.dexterity = min(character.vitals.dexterity + amount, 18)
                        elif attribute == "CONSTITUTION":
                            character.vitals.constitution = min(character.vitals.constitution + amount, 18)
                        elif attribute == "INTELLIGENCE":
                            character.vitals.intelligence = min(character.vitals.intelligence + amount, 18)
                        elif attribute == "WISDOM":
                            character.vitals.wisdom = min(character.vitals.wisdom + amount, 18)
                        elif attribute == "CHARISMA":
                            character.vitals.charisma = min(character.vitals.charisma + amount, 18)
                        # For generic categories (ANY, PHYSICAL, MENTAL) we assume the front end handles them.
                    else:
                        # For EPHEMERAL_POWER, FOCUS_BUDGET, or any unimplemented effects,
                        # simply log the effect data in the character's creation_data.
                        focus_ephemeral.append(effect)
    # Save the ephemeral effects log back to creation_data.
    creation_data['focus_ephemeral'] = focus_ephemeral
    character.creation_data = creation_data

    character.save()

def apply_edge_selection(character, selection):
    """
    Applies the chosen edge selection to the given character.
    Expects 'selection' to be a dictionary with an "edges" key containing a list
    of objects with: { id, rank, any_skill_choice } and an optional used_underdog flag.
    """
    edges_list = selection.get("edges")
    if edges_list is None:
        raise serializers.ValidationError("No edges provided in edge_selection.")

    # Replace any existing character edges
    character.character_edges.all().delete()

    for edge_item in edges_list:
        edge_id = edge_item.get("id")
        rank = edge_item.get("rank", 1)
        any_skill_choice = edge_item.get("any_skill_choice", None)

        try:
            edge_obj = Edge.objects.get(id=edge_id)
        except Edge.DoesNotExist:
            raise serializers.ValidationError(f"Edge with id {edge_id} does not exist.")

        # Create the pivot record for this edge
        CharacterEdge.objects.create(character=character, edge=edge_obj, rank=rank)

        # Process any immediate effects from the edge's effect_data
        if edge_obj.effect_data:
            for effect in edge_obj.effect_data:
                effect_type = effect.get("type")
                if effect_type == "GRANT_SKILL":
                    skill_name = effect.get("skill_name")
                    # For "ANY" or "ANY_COMBAT" choices, use the user's selection
                    if skill_name in ["ANY", "ANY_COMBAT"]:
                        if not any_skill_choice:
                            raise serializers.ValidationError(
                                f"Edge '{edge_obj.name}' requires a specific skill choice."
                            )
                        chosen_skill = any_skill_choice
                    else:
                        chosen_skill = skill_name
                    modifier = {
                        "modifier_type": "SKILL",
                        "skill_name": chosen_skill,
                        "points": effect.get("points", 0)
                    }
                    apply_modifiers(character, [modifier])
                elif effect_type == "MOD_FORMULA":
                    creation_data = character.creation_data or {}
                    creation_data['hp_formula'] = effect.get("value")
                    character.creation_data = creation_data
                elif effect_type == "MOD_TRAUMA_TARGET":
                    creation_data = character.creation_data or {}
                    creation_data.setdefault('trauma_target_mod', 0)
                    creation_data['trauma_target_mod'] += effect.get("amount", 0)
                    character.creation_data = creation_data
                # (Additional effect types can be handled here.)
    # Store the used_underdog flag if provided
    if selection.get("used_underdog"):
        creation_data = character.creation_data or {}
        creation_data['used_underdog'] = True
        character.creation_data = creation_data

    character.save()

def apply_background_selection(character, selection):
    # Assign the selected background.
    background_id = selection.get('background_id')
    try:
        background = Background.objects.get(id=background_id)
    except Background.DoesNotExist:
        raise serializers.ValidationError("Invalid background_id provided.")
    character.background = background

    # Apply free skill:
    free_skill_name = background.free_skill
    try:
        free_skill = Skill.objects.get(name__iexact=free_skill_name)
    except Skill.DoesNotExist:
        raise serializers.ValidationError("The free skill defined in the background does not exist.")
    free_cs, created = CharacterSkill.objects.get_or_create(
        character=character,
        skill=free_skill,
        defaults={'level': 0}
    )
    if free_cs.level < 1:
        free_cs.level = 1
        free_cs.save()

    # Process additional results (roll-based or manual).
    if selection.get('mode') == 'roll':
        results = selection.get('results', [])
    else:
        results = selection.get('manual_choices', [])

    # Convert each result into a modifier dict.
    modifiers = []
    for item in results:
        if item.get('type') == "ATTRIBUTE":
            modifiers.append({
                'modifier_type': "ATTRIBUTE",
                'category': item.get('category'),
                'points': item.get('points', 0),
            })
        elif item.get('type') == "SKILL":
            modifiers.append({
                'modifier_type': "SKILL",
                'skill_name': item.get('name'),
                'points': item.get('points', 0),
            })
    # Apply the standard modifiers.
    apply_modifiers(character, modifiers)

    # Process bonus distribution if provided.
    bonus_distribution = selection.get('bonus_distribution')
    if bonus_distribution:
        for bonus in bonus_distribution:
            category = bonus.get('category', '').upper()
            assignments = bonus.get('assigned_attributes', {})
            bonus_points = bonus.get('points', 0)
            if sum(assignments.values()) != bonus_points:
                raise serializers.ValidationError("Total bonus assignment does not match bonus points.")
            for attr, pts in assignments.items():
                allowed_attrs = []
                if category == 'ANY':
                    allowed_attrs = ['strength', 'dexterity', 'constitution', 'intelligence', 'wisdom', 'charisma']
                elif category == 'PHYSICAL':
                    allowed_attrs = ['strength', 'dexterity', 'constitution']
                elif category == 'MENTAL':
                    allowed_attrs = ['intelligence', 'wisdom', 'charisma']
                if attr not in allowed_attrs:
                    raise serializers.ValidationError(f"Invalid attribute assignment: {attr} for category {category}.")
                current_val = getattr(character, attr)
                if current_val + pts > 18:
                    raise serializers.ValidationError(f"Assignment would exceed attribute cap for {attr}.")
                setattr(character, attr, current_val + pts)

    # Save the creation_data for traceability.
    creation_data = character.creation_data or {}
    creation_data['background_selection'] = selection
    creation_data['background_completed'] = True
    character.creation_data = creation_data
    character.save()

class SkillViewSet(viewsets.ModelViewSet):
    queryset = Skill.objects.all()
    serializer_class = SkillSerializer
    permission_classes = [permissions.IsAuthenticated]

class CharacterViewSet(viewsets.ModelViewSet):
    queryset = Character.objects.all()
    serializer_class = CharacterSerializer
    permission_classes = [permissions.IsAuthenticated]

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

    def get_queryset(self):
        if self.request.user.is_staff:
            return super().get_queryset()
        return super().get_queryset().filter(user=self.request.user)

    def update(self, request, *args, **kwargs):
        # Pop background_selection, edge_selection, and focus_selection from payload if present
        background_selection = request.data.pop('background_selection', None)
        edge_selection = request.data.pop('edge_selection', None)
        focus_selection = request.data.pop('focus_selection', None)

        character = self.get_object()

        # Update the character with other fields (including contacts payload if provided)
        serializer = self.get_serializer(character, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        if background_selection:
            try:
                apply_background_selection(character, background_selection)
            except serializers.ValidationError as e:
                return Response({"detail": e.detail}, status=400)
            serializer = self.get_serializer(character)

        if edge_selection:
            try:
                apply_edge_selection(character, edge_selection)
            except serializers.ValidationError as e:
                return Response({"detail": e.detail}, status=400)
            serializer = self.get_serializer(character)

        if focus_selection:
            try:
                apply_focus_selection(character, focus_selection)
            except serializers.ValidationError as e:
                return Response({"detail": e.detail}, status=400)
            serializer = self.get_serializer(character)

        return Response(serializer.data)


class BackgroundViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Background.objects.all()
    serializer_class = BackgroundSerializer
    permission_classes = [permissions.IsAuthenticated]

class EdgeViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Edge.objects.all()
    serializer_class = EdgeSerializer
    permission_classes = [permissions.IsAuthenticated]

class FocusViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Focus.objects.all()
    serializer_class = FocusSerializer
    permission_classes = [permissions.IsAuthenticated]


----- .\server\characters\__init__.py -----

default_app_config = 'characters.apps.CharactersConfig'


----- .\server\characters\fixtures\initial_backgrounds.json -----

[
  {
    "model": "characters.background",
    "pk": 1,
    "fields": {
      "name": "Bum",
      "description": "A street-smart survivor who's lived on society's edges.",
      "free_skill": "survive",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "survive", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "any_combat", "points": 1},
        "2": {"type": "SKILL", "name": "survive", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "sneak", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "talk", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "survive", "points": 1},
        "5": {"type": "SKILL", "name": "connect", "points": 1},
        "6": {"type": "SKILL", "name": "sneak", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1},
        "8": {"type": "SKILL", "name": "talk", "points": 1},
        "9": {"type": "SKILL", "name": "fix", "points": 1},
        "10": {"type": "SKILL", "name": "ANY", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 2,
    "fields": {
      "name": "Bureaucrat",
      "description": "Placeholder",
      "free_skill": "administer",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "administer", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "administer", "points": 1},
        "2": {"type": "SKILL", "name": "know", "points": 1},
        "3": {"type": "SKILL", "name": "talk", "points": 1},
        "4": {"type": "SKILL", "name": "program", "points": 1},
        "5": {"type": "SKILL", "name": "lead", "points": 1},
        "6": {"type": "SKILL", "name": "trade", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "administer", "points": 1},
        "2": {"type": "SKILL", "name": "know", "points": 1},
        "3": {"type": "SKILL", "name": "talk", "points": 1},
        "4": {"type": "SKILL", "name": "program", "points": 1},
        "5": {"type": "SKILL", "name": "lead", "points": 1},
        "6": {"type": "SKILL", "name": "trade", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 3,
    "fields": {
      "name": "Clergy",
      "description": "Placeholder",
      "free_skill": "lead",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "connect", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "lead", "points": 1},
        "2": {"type": "SKILL", "name": "talk", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "perform", "points": 1},
        "5": {"type": "SKILL", "name": "know", "points": 1},
        "6": {"type": "SKILL", "name": "heal", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "lead", "points": 1},
        "2": {"type": "SKILL", "name": "talk", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "perform", "points": 1},
        "5": {"type": "SKILL", "name": "know", "points": 1},
        "6": {"type": "SKILL", "name": "heal", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 4,
    "fields": {
      "name": "Coder",
      "description": "A skilled programmer with a talent for solving complex problems.",
      "free_skill": "program",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "program", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "program", "points": 1},
        "2": {"type": "SKILL", "name": "administer", "points": 1},
        "3": {"type": "SKILL", "name": "fix", "points": 1},
        "4": {"type": "SKILL", "name": "talk", "points": 1},
        "5": {"type": "SKILL", "name": "connect", "points": 1},
        "6": {"type": "SKILL", "name": "know", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "program", "points": 1},
        "2": {"type": "SKILL", "name": "administer", "points": 1},
        "3": {"type": "SKILL", "name": "fix", "points": 1},
        "4": {"type": "SKILL", "name": "talk", "points": 1},
        "5": {"type": "SKILL", "name": "connect", "points": 1},
        "6": {"type": "SKILL", "name": "know", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 5,
    "fields": {
      "name": "Corp Security",
      "description": "A corporate enforcer with training in combat and protection.",
      "free_skill": "any_combat",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "any_combat", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "any_combat", "points": 1},
        "2": {"type": "SKILL", "name": "administer", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "notice", "points": 1},
        "5": {"type": "SKILL", "name": "exert", "points": 1},
        "6": {"type": "SKILL", "name": "heal", "points": 1},
        "7": {"type": "SKILL", "name": "sneak", "points": 1},
        "8": {"type": "SKILL", "name": "lead", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "administer", "points": 1},
        "5": {"type": "SKILL", "name": "connect", "points": 1},
        "6": {"type": "SKILL", "name": "notice", "points": 1},
        "7": {"type": "SKILL", "name": "exert", "points": 1},
        "8": {"type": "SKILL", "name": "heal", "points": 1},
        "9": {"type": "SKILL", "name": "sneak", "points": 1},
        "10": {"type": "SKILL", "name": "lead", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 6,
    "fields": {
      "name": "Corper",
      "description": "Placeholder",
      "free_skill": "work",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "ANY", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "work", "points": 1},
        "2": {"type": "SKILL", "name": "talk", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "any_combat", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "sneak", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "work", "points": 1},
        "2": {"type": "SKILL", "name": "talk", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "any_combat", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "sneak", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 7,
    "fields": {
      "name": "Criminal",
      "description": "Placeholder.",
      "free_skill": "sneak",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "any_combat", "points": 1},
        "2": {"type": "SKILL", "name": "sneak", "points": 1},
        "3": {"type": "SKILL", "name": "notice", "points": 1},
        "4": {"type": "SKILL", "name": "connect", "points": 1},
        "5": {"type": "SKILL", "name": "talk", "points": 1},
        "6": {"type": "SKILL", "name": "survive", "points": 1},
        "7": {"type": "SKILL", "name": "exert", "points": 1},
        "8": {"type": "SKILL", "name": "lead", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "sneak", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "talk", "points": 1},
        "8": {"type": "SKILL", "name": "survive", "points": 1},
        "9": {"type": "SKILL", "name": "exert", "points": 1},
        "10": {"type": "SKILL", "name": "lead", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 8,
    "fields": {
      "name": "Doctor",
      "description": "Placeholder",
      "free_skill": "heal",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "survive", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "heal", "points": 1},
        "2": {"type": "SKILL", "name": "notice", "points": 1},
        "3": {"type": "SKILL", "name": "know", "points": 1},
        "4": {"type": "SKILL", "name": "talk", "points": 1},
        "5": {"type": "SKILL", "name": "administer", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "heal", "points": 1},
        "2": {"type": "SKILL", "name": "notice", "points": 1},
        "3": {"type": "SKILL", "name": "know", "points": 1},
        "4": {"type": "SKILL", "name": "talk", "points": 1},
        "5": {"type": "SKILL", "name": "administer", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1}
      }}},
      {
    "model": "characters.background",
    "pk": 9,
    "fields": {
      "name": "Drone Jockey",
      "description": "Placeholder.",
      "free_skill": "drive",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "drive", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "drive", "points": 1},
        "2": {"type": "SKILL", "name": "fix", "points": 1},
        "3": {"type": "SKILL", "name": "shoot", "points": 1},
        "4": {"type": "SKILL", "name": "notice", "points": 1},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "exert", "points": 1},
        "7": {"type": "SKILL", "name": "program", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "drive", "points": 1},
        "2": {"type": "SKILL", "name": "fix", "points": 1},
        "3": {"type": "SKILL", "name": "shoot", "points": 1},
        "4": {"type": "SKILL", "name": "notice", "points": 1},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "exert", "points": 1},
        "7": {"type": "SKILL", "name": "program", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 10,
    "fields": {
      "name": "Ganger",
      "description": "Placeholder",
      "free_skill": "any_combat",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "any_combat", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "any_combat", "points": 1},
        "2": {"type": "SKILL", "name": "connect", "points": 1},
        "3": {"type": "SKILL", "name": "survive", "points": 1},
        "4": {"type": "SKILL", "name": "notice", "points": 1},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "talk", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "connect", "points": 1},
        "5": {"type": "SKILL", "name": "survive", "points": 1},
        "6": {"type": "SKILL", "name": "notice", "points": 1},
        "7": {"type": "SKILL", "name": "sneak", "points": 1},
        "8": {"type": "SKILL", "name": "talk", "points": 1},
        "9": {"type": "SKILL", "name": "fix", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 11,
    "fields": {
      "name": "Laborer",
      "description": "Placeholder.",
      "free_skill": "exert",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "exert", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "exert", "points": 1},
        "2": {"type": "SKILL", "name": "work", "points": 1},
        "3": {"type": "SKILL", "name": "sneak", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "survive", "points": 1},
        "6": {"type": "SKILL", "name": "fix", "points": 1},
        "7": {"type": "SKILL", "name": "any_combat", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "exert", "points": 1},
        "5": {"type": "SKILL", "name": "work", "points": 1},
        "6": {"type": "SKILL", "name": "sneak", "points": 1},
        "7": {"type": "SKILL", "name": "trade", "points": 1},
        "8": {"type": "SKILL", "name": "survive", "points": 1},
        "9": {"type": "SKILL", "name": "fix", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 12,
    "fields": {
      "name": "Law Enforcement",
      "description": "Placeholder.",
      "free_skill": "administer",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "administer", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "administer", "points": 1},
        "2": {"type": "SKILL", "name": "any_combat", "points": 1},
        "3": {"type": "SKILL", "name": "notice", "points": 1},
        "4": {"type": "SKILL", "name": "sneak", "points": 1},
        "5": {"type": "SKILL", "name": "talk", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "heal", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "administer", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "sneak", "points": 1},
        "7": {"type": "SKILL", "name": "talk", "points": 1},
        "8": {"type": "SKILL", "name": "connect", "points": 1},
        "9": {"type": "SKILL", "name": "heal", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 13,
    "fields": {
      "name": "Manager",
      "description": "Placeholder.",
      "free_skill": "administer",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "administer", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "administer", "points": 1},
        "2": {"type": "SKILL", "name": "talk", "points": 1},
        "3": {"type": "SKILL", "name": "trade", "points": 1},
        "4": {"type": "SKILL", "name": "connect", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "lead", "points": 1},
        "7": {"type": "SKILL", "name": "program", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "administer", "points": 1},
        "2": {"type": "SKILL", "name": "talk", "points": 1},
        "3": {"type": "SKILL", "name": "trade", "points": 1},
        "4": {"type": "SKILL", "name": "connect", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "lead", "points": 1},
        "7": {"type": "SKILL", "name": "program", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 14,
    "fields": {
      "name": "Outlander",
      "description": "Placeholder.",
      "free_skill": "survive",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "survive", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "survive", "points": 1},
        "2": {"type": "SKILL", "name": "drive", "points": 1},
        "3": {"type": "SKILL", "name": "fix", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "any_combat", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "survive", "points": 1},
        "5": {"type": "SKILL", "name": "drive", "points": 1},
        "6": {"type": "SKILL", "name": "fix", "points": 1},
        "7": {"type": "SKILL", "name": "trade", "points": 1},
        "8": {"type": "SKILL", "name": "sneak", "points": 1},
        "9": {"type": "SKILL", "name": "connect", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 15,
    "fields": {
      "name": "Performer",
      "description": "Placeholder.",
      "free_skill": "perform",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "ANY", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "perform", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "perform", "points": 1},
        "2": {"type": "SKILL", "name": "lead", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "talk", "points": 1},
        "5": {"type": "SKILL", "name": "trade", "points": 1},
        "6": {"type": "SKILL", "name": "sneak", "points": 1},
        "7": {"type": "SKILL", "name": "any_combat", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "perform", "points": 1},
        "5": {"type": "SKILL", "name": "lead", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "talk", "points": 1},
        "8": {"type": "SKILL", "name": "trade", "points": 1},
        "9": {"type": "SKILL", "name": "sneak", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 16,
    "fields": {
      "name": "Soldier",
      "description": "Placeholder.",
      "free_skill": "any_combat",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "any_combat", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "any_combat", "points": 1},
        "2": {"type": "SKILL", "name": "exert", "points": 1},
        "3": {"type": "SKILL", "name": "lead", "points": 1},
        "4": {"type": "SKILL", "name": "notice", "points": 1},
        "5": {"type": "SKILL", "name": "survive", "points": 1},
        "6": {"type": "SKILL", "name": "heal", "points": 1},
        "7": {"type": "SKILL", "name": "administer", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "exert", "points": 1},
        "5": {"type": "SKILL", "name": "lead", "points": 1},
        "6": {"type": "SKILL", "name": "notice", "points": 1},
        "7": {"type": "SKILL", "name": "survive", "points": 1},
        "8": {"type": "SKILL", "name": "heal", "points": 1},
        "9": {"type": "SKILL", "name": "administer", "points": 1}
      }}},
      {
    "model": "characters.background",
    "pk": 17,
    "fields": {
      "name": "Spy",
      "description": "Placeholder.",
      "free_skill": "sneak",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "ANY", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "sneak", "points": 1},
        "2": {"type": "SKILL", "name": "notice", "points": 1},
        "3": {"type": "SKILL", "name": "talk", "points": 1},
        "4": {"type": "SKILL", "name": "connect", "points": 1},
        "5": {"type": "SKILL", "name": "program", "points": 1},
        "6": {"type": "SKILL", "name": "exert", "points": 1},
        "7": {"type": "SKILL", "name": "any_combat", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "sneak", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "talk", "points": 1},
        "7": {"type": "SKILL", "name": "connect", "points": 1},
        "8": {"type": "SKILL", "name": "program", "points": 1},
        "9": {"type": "SKILL", "name": "exert", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 18,
    "fields": {
      "name": "Trader",
      "description": "Placeholder.",
      "free_skill": "trade",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "trade", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "trade", "points": 1},
        "2": {"type": "SKILL", "name": "notice", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "fix", "points": 1},
        "5": {"type": "SKILL", "name": "talk", "points": 1},
        "6": {"type": "SKILL", "name": "administer", "points": 1},
        "7": {"type": "SKILL", "name": "any_combat", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1},
        "8": {"type": "SKILL", "name": "talk", "points": 1},
        "9": {"type": "SKILL", "name": "administer", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 19,
    "fields": {
      "name": "Streetwalker",
      "description": "Placeholder.",
      "free_skill": "talk",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "ANY", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "talk", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "talk", "points": 1},
        "2": {"type": "SKILL", "name": "perform", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "notice", "points": 1},
        "7": {"type": "SKILL", "name": "heal", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "talk", "points": 1},
        "2": {"type": "SKILL", "name": "perform", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "notice", "points": 1},
        "7": {"type": "SKILL", "name": "heal", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 20,
    "fields": {
      "name": "Technician",
      "description": "Placeholder.",
      "free_skill": "fix",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "fix", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "fix", "points": 1},
        "2": {"type": "SKILL", "name": "program", "points": 1},
        "3": {"type": "SKILL", "name": "exert", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "drive", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "fix", "points": 1},
        "2": {"type": "SKILL", "name": "program", "points": 1},
        "3": {"type": "SKILL", "name": "exert", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "drive", "points": 1}
      }
    }
  }


]


----- .\server\characters\fixtures\initial_edges.json -----

[
  {
    "model": "characters.edge",
    "pk": 1,
    "fields": {
      "name": "Educated",
      "description": "You may pick a bonus skill of your choice. Whenever you gain skill points from character level advancement, you get a bonus skill point.",
      "category": "COMMON",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "GRANT_SKILL", "skill_name": "ANY", "points": 1 },
        { "type": "LEVEL_UP_BONUS", "bonus_skill_points": 1 }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 2,
    "fields": {
      "name": "Face",
      "description": "Gain Connect as a bonus skill. Once per game week, you may conjure a temporary Acquaintance Contact of your choice.",
      "category": "COMMON",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "GRANT_SKILL", "skill_name": "Connect", "points": 1 },
        { "type": "EPHEMERAL_POWER", "name": "temporary_acquaintance", "frequency": "WEEKLY" }
      ],
      "usage_notes": "Once per game week, gain a temporary Acquaintance Contact.",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 3,
    "fields": {
      "name": "Focused",
      "description": "You begin play with an extra Focus pick. This Edge may be chosen more than once.",
      "category": "COMMON",
      "multi_allowed": true,
      "prerequisites": {},
      "effect_data": [
        { "type": "GRANT_FOCUS", "count": 1 }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 4,
    "fields": {
      "name": "Ghost",
      "description": "Gain Sneak as a bonus skill, and your Fighting Withdrawal action becomes an On Turn action. Once per scene, reroll a failed Sneak check; once per game day, move up to 10 meters unseen.",
      "category": "COMMON",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "GRANT_SKILL", "skill_name": "Sneak", "points": 1 },
        { "type": "EPHEMERAL_POWER", "name": "reroll_sneak", "frequency": "SCENE" },
        { "type": "EPHEMERAL_POWER", "name": "vanish_move", "frequency": "DAILY", "distance": 10 }
      ],
      "usage_notes": "Once per scene, reroll a failed Sneak check; once per day, move up to 10m unseen.",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 5,
    "fields": {
      "name": "Hacker",
      "description": "Gain Program as a bonus skill. Begin play with an installed Cranial Jack and a scrap deck. Each round, gain a bonus Main Action for hacking-related actions.",
      "category": "COMMON",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "GRANT_SKILL", "skill_name": "Program", "points": 1 },
        { "type": "GRANT_GEAR", "gear": "Cranial Jack", "description": "Installed at start" },
        { "type": "BONUS_ACTION", "action": "Hacking", "frequency": "ROUND" }
      ],
      "usage_notes": "Provides bonus Main Action each round for hacking.",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 6,
    "fields": {
      "name": "Hard To Kill",
      "description": "Instead of rolling 1d6 per level for your hit points, roll 1d6+2. Your base Trauma Target increases by +1.",
      "category": "COMMON",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "MOD_FORMULA", "target": "hit_dice", "value": "1d6+2" },
        { "type": "MOD_TRAUMA_TARGET", "amount": 1 }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 7,
    "fields": {
      "name": "Killing Blow",
      "description": "Gain a combat skill as a bonus. Damage increases by 1 point per two levels and any Trauma Die gets a +1 bonus.",
      "category": "COMMON",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "GRANT_SKILL", "skill_name": "ANY_COMBAT", "points": 1 },
        { "type": "SCALING_BONUS", "bonus": "damage_increase", "per_levels": 2, "increment": 1 },
        { "type": "SCALING_BONUS", "bonus": "trauma_die", "per_levels": 2, "increment": 1 }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 8,
    "fields": {
      "name": "Masterful Expertise",
      "description": "Once per scene, as an Instant action, reroll a failed check for a non-combat skill.",
      "category": "COMMON",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "EPHEMERAL_POWER", "name": "reroll_noncombat", "frequency": "SCENE" }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 9,
    "fields": {
      "name": "On Target",
      "description": "Gain a combat skill as a bonus. Your basic attack bonus equals your character level instead of half.",
      "category": "COMMON",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "GRANT_SKILL", "skill_name": "ANY_COMBAT", "points": 1 },
        { "type": "MOD_FORMULA", "target": "attack_bonus", "value": "full_level" }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 10,
    "fields": {
      "name": "Prodigy",
      "description": "Pick an attribute other than Constitution; set it to 18 and grant it a +3 modifier. Cannot be taken if using the Underdog rule.",
      "category": "COMMON",
      "multi_allowed": false,
      "prerequisites": { "no_underdog": true },
      "effect_data": [
        { "type": "ATTRIBUTE_SET", "attribute": "ANY_BUT_CON", "value": 18, "modifier": 3 }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 11,
    "fields": {
      "name": "Operator’s Fortune",
      "description": "Once per game session, as an Instant action, roll 1d6. On a 1, nothing changes; on 2-5, you avert a bad event; on 6, it lands on an enemy or rival.",
      "category": "COMMON",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "EPHEMERAL_POWER", "name": "operator_fortune", "frequency": "SESSION" }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 12,
    "fields": {
      "name": "Veteran’s Luck",
      "description": "Once per scene, as an Instant action, convert a hit into a miss or vice versa.",
      "category": "COMMON",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "EPHEMERAL_POWER", "name": "veterans_luck", "frequency": "SCENE" }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 13,
    "fields": {
      "name": "Voice of the People",
      "description": "Gain both levels of the Pop Idol Focus and an additional Friend Contact related to your art.",
      "category": "COMMON",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "GRANT_FOCUS", "focus_name": "Pop Idol", "levels": 2 },
        { "type": "GRANT_CONTACT", "relationship": "friend", "count": 1 }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 14,
    "fields": {
      "name": "Wired",
      "description": "Begin play with up to $200,000 worth of cyber. No installation cost; maintenance is covered for two months. Redeemable later for a trade-in.",
      "category": "COMMON",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "GRANT_CYBER_FUNDS", "amount": 200000 },
        { "type": "FREE_MAINTENANCE", "duration": "2_months" }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 15,
    "fields": {
      "name": "Graced",
      "description": "You have innate magical abilities that enhance your physical or mental prowess. Gain the Graced powers and hindrances as described in section 6.3.0.",
      "category": "MAGICAL",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "GRANT_MAGICAL", "subtype": "graced" }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 16,
    "fields": {
      "name": "Spellcaster",
      "description": "You are a mage, capable of casting spells as described in section 6.1.0 and subject to a mage's limits in using cyberware.",
      "category": "MAGICAL",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "GRANT_MAGICAL", "subtype": "spellcaster" }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  },
  {
    "model": "characters.edge",
    "pk": 17,
    "fields": {
      "name": "Summoner",
      "description": "You are a summoner, capable of calling spirit servants as described in section 6.2.0, though you also face limits in using cyberware.",
      "category": "MAGICAL",
      "multi_allowed": false,
      "prerequisites": {},
      "effect_data": [
        { "type": "GRANT_MAGICAL", "subtype": "summoner" }
      ],
      "usage_notes": "",
      "source": "Cities Without Number"
    }
  }
]


----- .\server\characters\fixtures\initial_foci.json -----

[
  {
    "model": "characters.focus",
    "pk": 1,
    "fields": {
      "name": "Ace Driver",
      "description": "If it’s got wheels or wings, you can drive it with uncanny aptitude.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Applies only to vehicles, not drones. The gear budget increases by character level (see section 1.6.2).",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Drive as a bonus skill. Once per scene, reroll a failed driving or vehicle repair check. You have a vehicle gear budget and can replace lost/destroyed vehicles at a set rate.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Drive",
              "points": 1
            },
            {
              "type": "EPHEMERAL_POWER",
              "name": "reroll_driving_check",
              "frequency": "SCENE",
              "description": "Reroll one failed driving or related check per scene."
            },
            {
              "type": "FOCUS_BUDGET",
              "category": "vehicle",
              "base_amount": 5000,
              "description": "Vehicle gear budget at level 1."
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Gain Fix as a bonus skill. Increase your driven vehicle’s Speed by 1. Once per vehicle, add a free mod that only you can use and doesn’t require maintenance.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Fix",
              "points": 1
            },
            {
              "type": "MISC_BONUS",
              "target": "vehicle_speed",
              "amount": 1
            },
            {
              "type": "FREE_VEHICLE_MOD",
              "description": "Install one free mod in a vehicle you drive. Requires no Maintenance."
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 2,
    "fields": {
      "name": "Alert",
      "description": "Keenly aware of your surroundings, you’re almost impossible to ambush.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Helps avoid surprise and initiative disadvantages.",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Notice as a bonus skill. You cannot be surprised, nor be targeted by Execution Attacks from stealth. Your party rolls initiative twice and takes the better result.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Notice",
              "points": 1
            },
            {
              "type": "MISC_BONUS",
              "target": "no_surprise",
              "amount": 1
            },
            {
              "type": "INITIATIVE_BONUS",
              "description": "Roll initiative twice for the entire group, pick best."
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Always act first each round unless someone else is also Alert at level 2.",
          "effect_data": [
            {
              "type": "INITIATIVE_BONUS",
              "description": "Act first in combat each round."
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 3,
    "fields": {
      "name": "All Natural",
      "description": "Your physical and mental brilliance rejects most cyber augmentation.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 1,
      "multi_allowed": false,
      "prerequisites": {
        "no_cyberware": true
      },
      "usage_notes": "Cannot safely receive implants except trivial cosmetic ones.",
      "levels": [
        {
          "level": 1,
          "summary": "Gain any skill as a bonus skill. Increase one attribute’s modifier by +1 (max +3). At certain levels, can pick again. You can still suffer Traumatic Hits, but never suffer Major Injuries.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "ANY",
              "points": 1
            },
            {
              "type": "ATTRIBUTE_MOD",
              "attribute": "ANY_ONE",
              "amount": 1,
              "max_modifier": 3
            },
            {
              "type": "NO_MAJOR_INJURIES",
              "description": "You never suffer Major Injuries from Traumatic Hits."
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 4,
    "fields": {
      "name": "Armsmaster",
      "description": "You excel at melee or thrown-weapon combat (not unarmed).",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Doesn’t stack with Deadeye or other skill-level-to-damage Foci.",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Stab as a bonus skill. Ready a stowed melee/thrown weapon as an Instant action. Add your Stab skill level to damage or Shock when using melee/thrown weapons.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Stab",
              "points": 1
            },
            {
              "type": "MISC_BONUS",
              "target": "stab_skill_damage",
              "amount": 1
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Your melee Shock always applies as if target AC were 10. +1 to hit with all thrown or melee attacks.",
          "effect_data": [
            {
              "type": "SHOCK_AC_BYPASS",
              "value": 10
            },
            {
              "type": "MISC_BONUS",
              "target": "hit_roll",
              "amount": 1,
              "description": "Applies only to thrown or melee attacks."
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 5,
    "fields": {
      "name": "Assassin",
      "description": "You’re skilled at sudden murder and Execution Attacks.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Sneak. You can conceal a pistol/knife from basic scans. At point-blank from surprise, you cannot miss with that weapon.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Sneak",
              "points": 1
            },
            {
              "type": "CONCEAL_WEAPON",
              "size": "pistol_or_knife"
            },
            {
              "type": "AUTO_HIT_FROM_SURPRISE",
              "range": "point_blank"
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: You can still Move before or after your Execution Attack, splitting the move around the kill. Movement is too quick to alert your victim.",
          "effect_data": [
            {
              "type": "EXECUTION_MOVE",
              "description": "Move action can be split around your Execution Attack."
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 6,
    "fields": {
      "name": "Authority",
      "description": "Your force of personality compels others to follow you.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Limited to NPC loyalty; does not affect PCs directly.",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Lead. Once per day, you can force a non-hostile NPC to comply with a request that isn’t obviously harmful.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Lead",
              "points": 1
            },
            {
              "type": "EPHEMERAL_POWER",
              "name": "request_compliance",
              "frequency": "DAILY"
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Those you lead gain a bonus to Morale, attack rolls, and +1 to all skill checks equal to your Lead skill. They won’t betray you unless forced.",
          "effect_data": [
            {
              "type": "MORALE_BONUS",
              "value": "lead_skill"
            },
            {
              "type": "HIT_BONUS",
              "value": "lead_skill"
            },
            {
              "type": "SKILL_BONUS",
              "value": 1
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 7,
    "fields": {
      "name": "Close Combatant",
      "description": "You excel at close-range gunplay and avoiding melee Shock.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Lets you shoot pistol-sized weapons in melee without penalty and avoid Shock.",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain any combat skill. You can use a pistol in melee without a -4. Ignore Shock from melee attacks, even unarmored.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "ANY_COMBAT",
              "points": 1
            },
            {
              "type": "IGNORE_MELEE_SHOCK",
              "description": "You do not suffer Shock damage in melee."
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Your melee Shock always treats targets as if AC 10. Fighting Withdrawal is an On Turn action (no Main Action).",
          "effect_data": [
            {
              "type": "SHOCK_AC_BYPASS",
              "value": 10
            },
            {
              "type": "FIGHTING_WITHDRAWAL_UPGRADE"
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 8,
    "fields": {
      "name": "Cyberdoc",
      "description": "You’re specially gifted at implanting and maintaining cyberware.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Fix and Heal. Start with a cyberdoc kit. +2 on surgery checks. Performing maintenance on someone reduces their total System Strain by 1.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Fix",
              "points": 1
            },
            {
              "type": "GRANT_SKILL",
              "skill_name": "Heal",
              "points": 1
            },
            {
              "type": "GRANT_GEAR",
              "gear": "cyberdoc_kit",
              "description": "Basic medical kit for implants."
            },
            {
              "type": "SURGERY_BONUS",
              "amount": 2
            },
            {
              "type": "SYSTEM_STRAIN_REDUCE",
              "amount": 1
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Maintenance reduces System Strain by 2. You never fail to install cyber. Once per patient, build/install a cyber mod at no cost.",
          "effect_data": [
            {
              "type": "SYSTEM_STRAIN_REDUCE",
              "amount": 2
            },
            {
              "type": "NO_IMPLANT_FAILURE"
            },
            {
              "type": "FREE_CYBER_MOD"
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 9,
    "fields": {
      "name": "Deadeye",
      "description": "You’re a crack shot with ranged weapons, including thrown.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Doesn’t stack with Armsmaster if you’re throwing weapons.",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Shoot. Ready a stowed ranged weapon as an Instant action. Add your Shoot skill level to its damage.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Shoot",
              "points": 1
            },
            {
              "type": "MISC_BONUS",
              "target": "shoot_skill_damage",
              "amount": 1
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Reload guns or crossbows as an On Turn action if it normally takes a round. You can use two-handed ranged weapons in melee. Once per scene, automatically hit an inanimate target (unless physically impossible).",
          "effect_data": [
            {
              "type": "FAST_RELOAD"
            },
            {
              "type": "RANGED_IN_MELEE_OK"
            },
            {
              "type": "EPHEMERAL_POWER",
              "name": "auto_hit_inanimate",
              "frequency": "SCENE"
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 10,
    "fields": {
      "name": "Diplomat",
      "description": "You know how to get your way in personal negotiations.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Only works if the other party is actually willing to listen.",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Talk. You speak all common local languages. Reroll 1s on negotiation or diplomacy checks.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Talk",
              "points": 1
            },
            {
              "type": "LANGUAGE_BONUS",
              "description": "Speak the city’s common tongues."
            },
            {
              "type": "REROLL_ONES",
              "skill_categories": ["negotiation"]
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Once per game session, shift an intelligent NPC’s reaction one step friendlier if you can talk to them for at least 30 seconds.",
          "effect_data": [
            {
              "type": "EPHEMERAL_POWER",
              "name": "shift_reaction_friendlier",
              "frequency": "SESSION"
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 11,
    "fields": {
      "name": "Drone Pilot",
      "description": "You have a special knack for drone operation and maintenance.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Grants a separate drone gear budget. You can replicate destroyed drones weekly.",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Drive and Fix. You start with a Remote Control Unit cyber plus a drone budget. You can fix or rebuild your drones quickly.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Drive",
              "points": 1
            },
            {
              "type": "GRANT_SKILL",
              "skill_name": "Fix",
              "points": 1
            },
            {
              "type": "GRANT_GEAR",
              "gear": "Remote_Control_Unit_Cyber",
              "description": "Installed at start."
            },
            {
              "type": "FOCUS_BUDGET",
              "category": "drone",
              "base_amount": 1000,
              "description": "Drone gear budget at level 1."
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Once per scene, gain a bonus Main Action to command a drone. Your drones gain +2 to hit rolls while you command them.",
          "effect_data": [
            {
              "type": "EPHEMERAL_POWER",
              "name": "bonus_drone_action",
              "frequency": "SCENE"
            },
            {
              "type": "MISC_BONUS",
              "target": "drone_hit_roll",
              "amount": 2
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 12,
    "fields": {
      "name": "Expert Programmer",
      "description": "You go beyond mere hacking, shaping code like clay in your hands.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Interacts with cyberspace program writing and memory usage.",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Program. You can maintain extra program elements (char level +2). Once per day, on-the-fly reassign one Subject element to another.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Program",
              "points": 1
            },
            {
              "type": "PROGRAM_CAPACITY",
              "extra": 2
            },
            {
              "type": "EPHEMERAL_POWER",
              "name": "change_subject_element",
              "frequency": "DAILY"
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Your program elements take half Memory. A cyberdeck you use gains a CPU bonus equal to your Program skill.",
          "effect_data": [
            {
              "type": "HALF_MEMORY_USAGE"
            },
            {
              "type": "CYBERDECK_CPU_BONUS",
              "formula": "program_skill"
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 13,
    "fields": {
      "name": "Healer",
      "description": "Your healing talents border on miraculous.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Heal. You can stabilize one Mortally Wounded ally per round as an On Turn action. Roll 3d6 drop lowest on Heal checks.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Heal",
              "points": 1
            },
            {
              "type": "FASTER_STABILIZE",
              "description": "Can stabilize mortally-wounded ally as On Turn action."
            },
            {
              "type": "SKILL_ROLL_BONUS",
              "method": "3d6_drop_lowest",
              "skill_name": "Heal"
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Double healing from medtech or drugs you apply. Once per day, you can provide 1d6+Heal HP to every injured ally with 10 minutes of first aid, with no System Strain cost.",
          "effect_data": [
            {
              "type": "DOUBLE_MEDTECH_HEAL"
            },
            {
              "type": "EPHEMERAL_POWER",
              "name": "mass_first_aid",
              "frequency": "DAILY"
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 14,
    "fields": {
      "name": "Henchkeeper",
      "description": "You pick up loyal (if not bright) followers wherever you go.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Lead. You can recruit normal henchmen quickly in any new locale. They won’t fight except in self-defense. You can have 1 henchman per 3 character levels.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Lead",
              "points": 1
            },
            {
              "type": "HENCHMEN_RECRUIT",
              "max_count_formula": "ceil(level/3)"
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Your henchmen are loyal and will fight except vs. overwhelming odds. They act as Basic Corp Security if pressed into combat. Skilled NPCs can be recruited if you’ve earned their devotion.",
          "effect_data": [
            {
              "type": "UPGRADE_HENCHMEN",
              "description": "They fight at Basic Corp Security competence."
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 15,
    "fields": {
      "name": "Many Faces",
      "description": "You maintain multiple deep-cover identities in corporate databases.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 1,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Allows easy replacement of identities if compromised.",
      "levels": [
        {
          "level": 1,
          "summary": "Gain Sneak. You can maintain one false identity per 3 character levels. These identities are fully authenticated in corp systems. Changing an identity takes a week of downtime.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Sneak",
              "points": 1
            },
            {
              "type": "MULTI_IDENTITY",
              "formula": "ceil(level/3)"
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 16,
    "fields": {
      "name": "Pop Idol",
      "description": "You have a devoted fan base ready to do your bidding.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Perform. Once per game week, mobilize ~100 fans for mild tasks or earn $1k/level from donations or merch sales.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Perform",
              "points": 1
            },
            {
              "type": "EPHEMERAL_POWER",
              "name": "fan_mobilization",
              "frequency": "WEEKLY"
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: You can rally up to 100 fans per character level. You can hide your involvement through local fan leaders. Donations double. Your Charisma modifier is +1 (max +2).",
          "effect_data": [
            {
              "type": "FAN_MOB_UPGRADE",
              "description": "Up to 100 fans x level. Donations/merch double."
            },
            {
              "type": "ATTRIBUTE_MOD",
              "attribute": "CHA",
              "amount": 1,
              "max_modifier": 2
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 17,
    "fields": {
      "name": "Roamer",
      "description": "You’ve traveled widely on foot or by stowing away on transport.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Similar to Ace Driver but more general. Also grants vehicle budget.",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Survive and Drive. You speak all common local languages. Never get lost. Acquire vehicles worth up to $5k, replace at $10k/week if lost.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Survive",
              "points": 1
            },
            {
              "type": "GRANT_SKILL",
              "skill_name": "Drive",
              "points": 1
            },
            {
              "type": "NO_GET_LOST"
            },
            {
              "type": "FOCUS_BUDGET",
              "category": "vehicle",
              "base_amount": 5000,
              "description": "Vehicle gear budget at level 1."
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Once per scene, reroll a failed travel-related skill check (driving, navigating, negotiating passage).",
          "effect_data": [
            {
              "type": "EPHEMERAL_POWER",
              "name": "reroll_travel_check",
              "frequency": "SCENE"
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 18,
    "fields": {
      "name": "Safe Haven",
      "description": "You have a knack for finding or establishing hidden safehouses.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Sneak. You can arrange a secure safehouse in a neighborhood after a week. It’s invisible to pursuit unless you blow its cover.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Sneak",
              "points": 1
            },
            {
              "type": "SAFEHOUSE_SETUP"
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Safehouses come with local defenders (gang, complicit cops, etc.) who’ll protect you from most threats. You can gear them with a tech workshop or level-1 cyberclinic.",
          "effect_data": [
            {
              "type": "UPGRADE_SAFEHOUSE_DEFENSE"
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 19,
    "fields": {
      "name": "Shocking Assault",
      "description": "Your melee strikes create unstoppable waves of harm around you.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Boosts your Shock damage with melee weapons.",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Punch or Stab. Your melee Shock applies vs. AC 10 (assuming the target is not immune).",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Punch_or_Stab",
              "points": 1
            },
            {
              "type": "SHOCK_AC_BYPASS",
              "value": 10
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Your melee (or unarmed) attacks gain +2 Shock. A successful hit never does less than that Shock value.",
          "effect_data": [
            {
              "type": "SHOCK_BONUS",
              "amount": 2
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 20,
    "fields": {
      "name": "Sniper’s Eye",
      "description": "You excel at ranged Execution Attacks.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Applies specifically to Execution Attacks with guns, bows, or thrown weapons.",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Shoot. When making an Execution Attack or target shooting, roll 3d6 drop the lowest die.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Shoot",
              "points": 1
            },
            {
              "type": "SKILL_ROLL_BONUS",
              "method": "3d6_drop_lowest",
              "applies_to": "execution_attack"
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: You do not miss with ranged Execution Attacks. The target takes a -4 penalty to their Physical save or suffers doubled damage if they pass anyway.",
          "effect_data": [
            {
              "type": "NO_MISS_EXECUTION"
            },
            {
              "type": "SAVE_PENALTY",
              "amount": -4,
              "save_type": "physical"
            },
            {
              "type": "DAMAGE_MULTIPLIER",
              "value": 2,
              "condition": "execution_save_success"
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 21,
    "fields": {
      "name": "Specialist",
      "description": "You are remarkably talented at one particular non-combat skill.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": true,
      "prerequisites": {},
      "usage_notes": "If taken multiple times, each instance must apply to a different skill.",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Pick a non-combat skill, gain it at level-0 if you don’t have it, or raise it by 1 if you do (up to 1). You roll 3d6 drop lowest for checks.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "ANY_NONCOMBAT",
              "points": 1
            },
            {
              "type": "SKILL_ROLL_BONUS",
              "method": "3d6_drop_lowest"
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: You roll 4d6 drop the two lowest on checks with that skill. (Skill level can be 1 now, but not more than 1 at creation.)",
          "effect_data": [
            {
              "type": "SKILL_ROLL_BONUS",
              "method": "4d6_drop_two_lowest"
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 22,
    "fields": {
      "name": "Tinker",
      "description": "You’re adept at building and modifying gear or cyberware.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Fix. Your Maintenance score is doubled, and normal mod costs in $ are halved (special components still needed).",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Fix",
              "points": 1
            },
            {
              "type": "MAINTENANCE_SCORE_MULT",
              "amount": 2
            },
            {
              "type": "MOD_COST_REDUCTION",
              "percentage": 50
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Your Fix is treated 1 level higher for mod building/maintenance (max Fix-5). Advanced mods require one fewer special component (min zero).",
          "effect_data": [
            {
              "type": "FIX_SKILL_BOOST",
              "amount": 1,
              "max_effective_skill": 5
            },
            {
              "type": "MOD_COMPONENT_REDUCTION",
              "amount": 1
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 23,
    "fields": {
      "name": "Unarmed Combatant",
      "description": "Your empty hands are lethal weapons.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Punch. Your unarmed damage scales with Punch skill, and can do lethal damage with a 1d6 x2 Trauma. If Punch≥1, you get Shock vs. AC15.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Punch",
              "points": 1
            },
            {
              "type": "SCALE_UNARMED_DAMAGE",
              "formula": "punch_skill_progression"
            },
            {
              "type": "UNARMED_TRAUMA",
              "die": "1d6",
              "rating": 2
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: Even on a miss, you deal 1d6 damage plus any Shock. Your lethal Trauma Die becomes 1d8.",
          "effect_data": [
            {
              "type": "MISS_DAMAGE",
              "amount": "1d6"
            },
            {
              "type": "UNARMED_TRAUMA",
              "die": "1d8",
              "rating": 2
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 24,
    "fields": {
      "name": "Unique Gift",
      "description": "A singular cyber system or innate ability that no normal gear can match.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 1,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Represents a special trait or item. Must be GM-approved. Shouldn’t be a trivial bonus.",
      "levels": [
        {
          "level": 1,
          "summary": "Pick a unique advantage that cannot be replicated by normal equipment. The GM decides if it’s balanced or requires System Strain.",
          "effect_data": [
            {
              "type": "CUSTOM_POWER",
              "description": "Player and GM define the specifics of this singular ability."
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 25,
    "fields": {
      "name": "Unregistered",
      "description": "You simply do not exist in government or corporate records.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 1,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "Difficult to own formal property or bank accounts, but you vanish from digital records.",
      "levels": [
        {
          "level": 1,
          "summary": "No official records link to you. Computer systems can’t reliably keep track. You can’t maintain a normal bank account or ID.",
          "effect_data": [
            {
              "type": "NO_CORP_RECORDS"
            }
          ]
        }
      ]
    }
  },
  {
    "model": "characters.focus",
    "pk": 26,
    "fields": {
      "name": "Whirlwind Assault",
      "description": "A dervish of deadly melee fury, hacking through groups of foes.",
      "version": "1.0.0",
      "category": "COMMON",
      "source": "Cities Without Number",
      "max_level": 2,
      "multi_allowed": false,
      "prerequisites": {},
      "usage_notes": "",
      "levels": [
        {
          "level": 1,
          "summary": "Level 1: Gain Stab or Punch. Once per scene, as an On Turn action, apply your Shock damage to all foes in melee range.",
          "effect_data": [
            {
              "type": "GRANT_SKILL",
              "skill_name": "Punch_or_Stab",
              "points": 1
            },
            {
              "type": "EPHEMERAL_POWER",
              "name": "shock_aoe",
              "frequency": "SCENE"
            }
          ]
        },
        {
          "level": 2,
          "summary": "Level 2: If you kill someone with a normal melee attack, you instantly gain a second attack in that round.",
          "effect_data": [
            {
              "type": "BONUS_ATTACK_ON_KILL"
            }
          ]
        }
      ]
    }
  }
]


----- .\server\characters\fixtures\initial_skills.json -----

[
    {
        "model": "characters.skill",
        "pk": 1,
        "fields": {
            "name": "Administer",
            "description": "Manage an organization, handle paperwork, analyze records, and keep an institution functioning on a daily basis.",
            "category": "administrative",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 2,
        "fields": {
            "name": "Connect",
            "description": "Find people who can be helpful and get them to cooperate with you.",
            "category": "social",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 3,
        "fields": {
            "name": "Drive",
            "description": "Drive vehicles, sail ships, fly planes, pilot drones, and perform basic repairs.",
            "category": "physical",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 4,
        "fields": {
            "name": "Exert",
            "description": "Apply physical strength and stamina to feats like running, jumping, or climbing.",
            "category": "physical",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 5,
        "fields": {
            "name": "Fix",
            "description": "Create and repair devices both simple and complex.",
            "category": "technical",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 6,
        "fields": {
            "name": "Heal",
            "description": "Provide medical or psychological treatment for injuries or illnesses.",
            "category": "medical",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 7,
        "fields": {
            "name": "Know",
            "description": "Recall facts about academic or scientific topics and history.",
            "category": "knowledge",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 8,
        "fields": {
            "name": "Lead",
            "description": "Inspire and convince others to follow you.",
            "category": "social",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 9,
        "fields": {
            "name": "Notice",
            "description": "Spot details and anomalies in your environment.",
            "category": "perception",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 10,
        "fields": {
            "name": "Perform",
            "description": "Showcase performance skills such as singing, dancing, or acting.",
            "category": "artistic",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 11,
        "fields": {
            "name": "Program",
            "description": "Operate or hack computers and communications equipment.",
            "category": "technical",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 12,
        "fields": {
            "name": "Punch",
            "description": "Used in unarmed combat; without training, the modifier is -1.",
            "category": "combat",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 13,
        "fields": {
            "name": "Shoot",
            "description": "Used for ranged weapon attacks.",
            "category": "combat",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 14,
        "fields": {
            "name": "Sneak",
            "description": "Move silently and remain unseen.",
            "category": "stealth",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 15,
        "fields": {
            "name": "Stab",
            "description": "Used for melee attacks with bladed weapons.",
            "category": "combat",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 16,
        "fields": {
            "name": "Survive",
            "description": "Use street smarts or wilderness skills to stay alive.",
            "category": "survival",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 17,
        "fields": {
            "name": "Talk",
            "description": "Persuade, charm, or deceive others through conversation.",
            "category": "social",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 18,
        "fields": {
            "name": "Trade",
            "description": "Negotiate, buy, or sell goods and services.",
            "category": "economic",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 19,
        "fields": {
            "name": "Work",
            "description": "Apply your skills in a specific profession or trade.",
            "category": "labor",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 20,
        "fields": {
            "name": "Cast",
            "description": "Cast spells (for magic-enabled campaigns).",
            "category": "magical",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 21,
        "fields": {
            "name": "Summon",
            "description": "Summon spirits or supernatural allies (for magic-enabled campaigns).",
            "category": "magical",
            "default_modifier": -1
        }
    }
]

----- .\server\characters\services\foci.py -----

# server/characters/services/foci.py

from rest_framework import serializers
from characters.models import Focus, CharacterFocus, CharacterSkill, Skill
from characters.services.modifiers import apply_modifiers

def apply_focus_selection(character, focus_selection):
    """
    Applies the chosen focus selection to the given character.
    Expects focus_selection to be a dictionary with a "foci" key containing a list of objects:
      { "id": <focus_id>, "rank": <chosen_rank>, "chosen_skill": <optional> }
    """
    # Clear any existing CharacterFocus entries for this character.
    character.character_focuses.all().delete()

    foci_list = focus_selection.get("foci", [])
    if not foci_list:
        raise serializers.ValidationError("No foci provided in focus_selection.")

    # Initialize a log for any ephemeral focus effects (to be implemented later)
    creation_data = character.creation_data or {}
    focus_ephemeral = creation_data.get('focus_ephemeral', [])

    for focus_item in foci_list:
        focus_id = focus_item.get("id")
        rank = focus_item.get("rank", 1)
        chosen_skill = focus_item.get("chosen_skill")  # optional

        try:
            focus_obj = Focus.objects.get(id=focus_id)
        except Focus.DoesNotExist:
            raise serializers.ValidationError(f"Focus with id {focus_id} does not exist.")

        # Validate the chosen rank does not exceed the focus's max_level.
        if rank > focus_obj.max_level:
            raise serializers.ValidationError(
                f"Focus '{focus_obj.name}' cannot be taken at rank {rank} (max level: {focus_obj.max_level})."
            )

        # Create the pivot record in CharacterFocus.
        CharacterFocus.objects.create(
            character=character,
            focus=focus_obj,
            rank=rank,
            chosen_skill=chosen_skill
        )

        # Process immediate effects from the focus's levels.
        levels_data = focus_obj.levels or []
        for level_entry in levels_data:
            if level_entry.get("level", 0) <= rank:
                for effect in level_entry.get("effect_data", []):
                    effect_type = effect.get("type")
                    if effect_type == "GRANT_SKILL":
                        # Retrieve the skill and grant bonus, but cap at level 1 during creation.
                        skill_name = effect.get("skill_name")
                        bonus_points = effect.get("points", 0)
                        try:
                            skill_obj = Skill.objects.get(name__iexact=skill_name)
                        except Skill.DoesNotExist:
                            continue
                        cs = CharacterSkill.objects.filter(character=character, skill=skill_obj).first()
                        if cs is None:
                            level = 1 if bonus_points >= 1 else 0
                            CharacterSkill.objects.create(character=character, skill=skill_obj, level=level)
                        else:
                            if cs.level < 1 and bonus_points >= 1:
                                cs.level = 1
                                cs.save()
                    elif effect_type == "ATTRIBUTE_MOD":
                        # Apply attribute modification and cap at 18.
                        attribute = effect.get("attribute", "").upper()
                        amount = effect.get("amount", 0)
                        if attribute == "STRENGTH":
                            character.vitals.strength = min(character.vitals.strength + amount, 18)
                        elif attribute == "DEXTERITY":
                            character.vitals.dexterity = min(character.vitals.dexterity + amount, 18)
                        elif attribute == "CONSTITUTION":
                            character.vitals.constitution = min(character.vitals.constitution + amount, 18)
                        elif attribute == "INTELLIGENCE":
                            character.vitals.intelligence = min(character.vitals.intelligence + amount, 18)
                        elif attribute == "WISDOM":
                            character.vitals.wisdom = min(character.vitals.wisdom + amount, 18)
                        elif attribute == "CHARISMA":
                            character.vitals.charisma = min(character.vitals.charisma + amount, 18)
                    else:
                        # For unimplemented or ephemeral effects, log them for future processing.
                        focus_ephemeral.append(effect)
    creation_data['focus_ephemeral'] = focus_ephemeral
    character.creation_data = creation_data
    character.save()


----- .\server\characters\services\modifiers.py -----

# server/characters/services/modifiers.py

from rest_framework import serializers
from characters.models import CharacterSkill, Skill

def apply_modifiers(character, modifiers):
    """
    Applies the given modifiers to the character.
    - No skill should exceed level-1 during character creation.
    - Attributes are capped at 18.
    - 'ANY', 'PHYSICAL', or 'MENTAL' attribute bonuses are handled on the front end,
      unless a specific attribute is given.
    """
    for mod in modifiers:
        if mod['modifier_type'] == 'ATTRIBUTE':
            category = mod.get('category', '').upper()
            points = mod.get('points', 0)

            if category not in ['ANY', 'PHYSICAL', 'MENTAL']:
                if category == 'STRENGTH':
                    new_val = min(character.vitals.strength + points, 18)
                    character.vitals.strength = new_val
                elif category == 'DEXTERITY':
                    new_val = min(character.vitals.dexterity + points, 18)
                    character.vitals.dexterity = new_val
                # ... Repeat for other attributes if desired

        elif mod['modifier_type'] == 'SKILL':
            skill_name = mod.get('skill_name')
            if not skill_name:
                continue
            try:
                skill_obj = Skill.objects.get(name__iexact=skill_name)
            except Skill.DoesNotExist:
                continue

            bonus_points = mod.get('points', 0)
            cs = CharacterSkill.objects.filter(character=character, skill=skill_obj).first()

            if cs is None:
                # If awarding 1 point -> level-0, else -> level-1, but never exceed 1
                initial_level = 0 if bonus_points == 1 else 1
                CharacterSkill.objects.create(
                    character=character, skill=skill_obj,
                    level=min(initial_level, 1)
                )
            else:
                # Already have this skill
                if cs.level >= 1 and bonus_points >= 1:
                    # ---------------------------------------------
                    # OPTION 5: Instead of raising an error, skip it:
                    # ---------------------------------------------
                    # Simply ignore awarding more points to a level-1 skill.
                    # If you prefer to throw an error, uncomment:
                    #
                    # raise serializers.ValidationError(
                    #     f"Skill '{skill_obj.name}' is already level-1. Choose another skill."
                    # )
                    #
                    # If skipping, do nothing:
                    continue

                # If skill was level-0, awarding 1+ point sets it to 1
                if cs.level == 0 and bonus_points >= 1:
                    cs.level = 1
                    cs.save()

    character.save()


----- .\server\users\admin.py -----

from django.contrib import admin
from django.contrib.auth.models import User
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin

class UserAdmin(BaseUserAdmin):
    list_display = ('username', 'email', 'first_name', 'last_name', 'is_staff', 'get_groups')

    def get_groups(self, obj):
        return ', '.join([g.name for g in obj.groups.all()])
    get_groups.short_description = 'Groups'

# Re-register UserAdmin
admin.site.unregister(User)
admin.site.register(User, UserAdmin)

----- .\server\users\apps.py -----

from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'users'


----- .\server\users\models.py -----

from django.db import models

# Create your models here.


----- .\server\users\serializers.py -----


from django.contrib.auth.models import User
from rest_framework import serializers


class UserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True)

    class Meta:
        model = User
        fields = ('id', 'username', 'password', 'email')  # add fields as desired

    def create(self, validated_data):
        # Use Django's create_user method which properly hashes the password
        user = User.objects.create_user(
            username=validated_data['username'],
            email=validated_data.get('email'),
            password=validated_data['password']
        )
        return user


----- .\server\users\tests.py -----

from django.test import TestCase

# Create your tests here.


----- .\server\users\views.py -----

from django.shortcuts import render
from rest_framework import viewsets, permissions, generics
from .serializers import UserSerializer
from django.contrib.auth.models import User
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def user_roles(request):
    roles = request.user.groups.values_list('name', flat=True)
    return Response({"roles": roles})

# The registration view:
class UserRegistrationView(generics.CreateAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    permission_classes = [permissions.AllowAny]  # Registration is open


----- .\server\users\__init__.py -----



----- .\server\venture\asgi.py -----

"""
ASGI config for venture project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'venture.settings')

application = get_asgi_application()


----- .\server\venture\settings.py -----

"""
Django settings for venture project.

Generated by 'django-admin startproject' using Django 5.1.7.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-odos-ixh%c^hmz0pnme-%3@c=ch9=$u8gu_0=#!=+)@htd$@9i'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # Third-party
    'rest_framework',
    'rest_framework_simplejwt.token_blacklist',
    'corsheaders',

    # Your apps
    'characters',
    'users',
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'venture.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'venture.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = 'static/'
STATICFILES_DIRS = [BASE_DIR / "static"]

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
]

CORS_ALLOW_CREDENTIALS = True

----- .\server\venture\urls.py -----

from django.contrib import admin
from django.urls import path, include
from rest_framework import routers
from characters.views import CharacterViewSet, SkillViewSet, BackgroundViewSet, EdgeViewSet, FocusViewSet
from users.views import UserRegistrationView, user_roles
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)
from users.views import user_roles

router = routers.DefaultRouter()
router.register(r'characters', CharacterViewSet, basename='characters')
router.register(r'skills', SkillViewSet, basename='skills')
router.register(r'backgrounds', BackgroundViewSet, basename='backgrounds')
router.register(r'edges', EdgeViewSet, basename='edges')
router.register(r'foci', FocusViewSet, basename='foci')

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include(router.urls)),
    path('api/register/', UserRegistrationView.as_view(), name='register'),
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    path('api/user_roles/', user_roles, name='user_roles'),
]



----- .\server\venture\wsgi.py -----

"""
WSGI config for venture project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'venture.settings')

application = get_wsgi_application()


----- .\server\venture\__init__.py -----

