

----- .\client\src\App.css -----

.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


----- .\client\src\App.js -----

// ./client/src/App.js
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import Home from './components/Home';
import CharacterList from './components/CharacterList';
import CharacterForm from './components/CharacterForm';
import Login from './components/Login';
import Register from './components/Register';
import Welcome from './components/Welcome';
import Layout from './components/Layout';
import ProtectedRoute from './components/ProtectedRoute';
import ViewCharacter from './components/ViewCharacter';
import AttributeCreationWrapper from './components/AttributeCreationWrapper';
import AttributeCreationStarter from './components/AttributeCreationStarter';
import NewCharacterChoice from './components/NewCharacterChoice';
import BackgroundCreation from './components/BackgroundCreation';
import Contacts from './components/Contacts';
import Edges from './components/Edges';

function App() {
  return (
    <AuthProvider>
      <Router>
        <Routes>
          {/* All pages share the Layout */}
          <Route element={<Layout />}>
            {/* Protected routes */}
            <Route path="/home" element={<ProtectedRoute><Home /></ProtectedRoute>} />
            <Route path="/characters" element={<ProtectedRoute><CharacterList /></ProtectedRoute>} />
            <Route path="/new" element={<ProtectedRoute><NewCharacterChoice /></ProtectedRoute>} />
            <Route path="/new/manual" element={<ProtectedRoute><CharacterForm /></ProtectedRoute>} />
            <Route path="/new/discover" element={<ProtectedRoute><AttributeCreationStarter /></ProtectedRoute>} />
            <Route path="/characters/:id/attributes" element={<ProtectedRoute><AttributeCreationWrapper /></ProtectedRoute>} />
            <Route path="/characters/:id/backgrounds" element={<ProtectedRoute><BackgroundCreation /></ProtectedRoute>} />
            <Route path="/edges" element={<ProtectedRoute><Edges /></ProtectedRoute>} />
            <Route path="/characters/:id/contacts" element={<ProtectedRoute><Contacts /></ProtectedRoute>} />

            {/* Moved this route correctly inside the Layout */}
            <Route path="/characters/:id" element={<ProtectedRoute><ViewCharacter /></ProtectedRoute>} />

            {/* Public routes */}
            <Route path="/welcome" element={<Welcome />} />
            <Route path="/login" element={<Login />} />
            <Route path="/register" element={<Register />} />

            {/* Catch-all redirect */}
            <Route path="*" element={<ProtectedRoute><Navigate to="/home" replace /></ProtectedRoute>} />
          </Route>
        </Routes>
      </Router>
    </AuthProvider>
  );
}

export default App;


----- .\client\src\App.test.js -----

import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


----- .\client\src\dark-theme.css -----

/* dark-theme.css */

body {
  background-color: #121212;
  color: #e0e0e0;
  font-family: 'Roboto', 'Rajdhani', sans-serif;
}

nav {
  background-color: rgba(255,255,255,0.05);
  padding: 10px;
  border-bottom: 1px solid #0fffc1;
}

nav a,
nav button {
  color: #0fffc1;
  text-decoration: none;
  font-weight: bold;
  margin-right: 10px;
  transition: 0.3s ease;
}

nav a:hover,
nav button:hover {
  color: #ff2079;
  text-shadow: 0 0 5px #ff2079, 0 0 10px #ff2079;
}

button,
input {
  background-color: rgba(255,255,255,0.1);
  border: 1px solid #0fffc1;
  border-radius: 6px;
  padding: 8px 12px;
  color: #e0e0e0;
  outline: none;
  transition: box-shadow 0.2s ease;
}

button:hover,
input:focus {
  box-shadow: 0 0 10px #0fffc1, inset 0 0 5px #0fffc1;
}

form div {
  margin-bottom: 15px;
}

input[type="number"],
input[type="text"],
input[type="password"],
input[type="email"] {
  width: 100%;
}

.card {
  background-color: rgba(255,255,255,0.05);
  padding: 20px;
  border-radius: 6px;
  box-shadow: 0 0 5px rgba(0,0,0,0.6);
  margin-bottom: 20px;
}

.error {
  color: #f7ff00;
}

.success {
  color: #0fffc1;
}


----- .\client\src\index.css -----

/* index.css */
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


----- .\client\src\index.js -----

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import reportWebVitals from './reportWebVitals';
import './index.css';
import './dark-theme.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

----- .\client\src\reportWebVitals.js -----

const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


----- .\client\src\setupTests.js -----

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


----- .\client\src\components\AttributeCreation.js -----

import React, { useState, useEffect } from 'react';
import axios from '../services/api';
import { useNavigate } from 'react-router-dom';

const ATTRIBUTE_NAMES = ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"];
const MANUAL_OPTIONS = [14, 12, 11, 10, 9, 7];

const roll3d6 = () => {
  let total = 0;
  for (let i = 0; i < 3; i++) {
    total += Math.floor(Math.random() * 6) + 1;
  }
  return total;
};

const AttributeCreation = ({ characterId }) => {
  const [mode, setMode] = useState("random"); // "random" or "manual"
  const [attributes, setAttributes] = useState({
    strength: 10,
    dexterity: 10,
    constitution: 10,
    intelligence: 10,
    wisdom: 10,
    charisma: 10
  });
  const [manualAttributes, setManualAttributes] = useState({
    strength: null,
    dexterity: null,
    constitution: null,
    intelligence: null,
    wisdom: null,
    charisma: null
  });
  const [error, setError] = useState(null);
  const navigate = useNavigate();

  // When switching to manual mode, reset manual attributes to null.
  useEffect(() => {
    if (mode === "manual") {
      setManualAttributes({
        strength: null,
        dexterity: null,
        constitution: null,
        intelligence: null,
        wisdom: null,
        charisma: null
      });
    }
  }, [mode]);

  // Handler for random roll button
  const handleRoll = () => {
    const newAttributes = {};
    ATTRIBUTE_NAMES.forEach(attr => {
      newAttributes[attr] = roll3d6();
    });
    setAttributes(newAttributes);
  };

  // Handler for manual assignment changes.
  // 'value' is converted to a number; if empty, we store null.
  const handleManualChange = (attr, value) => {
    setManualAttributes(prev => ({
      ...prev,
      [attr]: value === "" ? null : parseInt(value, 10)
    }));
  };

  // Function to get available options for a given attribute.
  // It returns options not already selected by other fields,
  // while preserving the already-selected value (if any).
  const getAvailableOptions = (currentAttr) => {
    const usedValues = ATTRIBUTE_NAMES.filter(a => a !== currentAttr)
      .map(a => manualAttributes[a])
      .filter(v => v !== null);
    return MANUAL_OPTIONS.filter(option =>
      !usedValues.includes(option) || option === manualAttributes[currentAttr]
    );
  };

  // Handler to confirm the current attribute selections.
  const handleConfirm = async () => {
    if (mode === "manual") {
      // Ensure every attribute has a selection.
      for (let attr of ATTRIBUTE_NAMES) {
        if (manualAttributes[attr] === null) {
          setError("Please select a value for every attribute.");
          return;
        }
      }
      // Merge manual values into attributes.
      setAttributes(manualAttributes);
      setError(null);
      try {
        await axios.patch(`/characters/${characterId}/`, {
          ...manualAttributes,
          creation_data: { step: "attributes" }
        });
        navigate(`/characters/${characterId}/backgrounds`);
      } catch (err) {
        console.error("Error updating attributes:", err);
      }
    } else {
      // For random mode, attributes are already set.
      try {
        await axios.patch(`/characters/${characterId}/`, {
          ...attributes,
          creation_data: { step: "attributes" }
        });
        navigate(`/characters/${characterId}/backgrounds`);
      } catch (err) {
        console.error("Error updating attributes:", err);
      }
    }
  };

  return (
    <div className="card">
      <h2>Character Creation: Attributes</h2>
      <div>
        <label>
          <input
            type="radio"
            value="random"
            checked={mode === "random"}
            onChange={() => setMode("random")}
          />
          Roll Attributes Randomly
        </label>
        <label style={{ marginLeft: '20px' }}>
          <input
            type="radio"
            value="manual"
            checked={mode === "manual"}
            onChange={() => setMode("manual")}
          />
          Assign Manually
        </label>
      </div>

      {mode === "random" && (
        <div>
          <button onClick={handleRoll}>Roll Attributes</button>
          <div style={{ marginTop: '10px' }}>
            {ATTRIBUTE_NAMES.map(attr => (
              <div key={attr}>
                <strong>{attr.charAt(0).toUpperCase() + attr.slice(1)}:</strong> {attributes[attr]}
              </div>
            ))}
          </div>
        </div>
      )}

      {mode === "manual" && (
        <div>
          {ATTRIBUTE_NAMES.map(attr => (
            <div key={attr} style={{ marginBottom: '10px' }}>
              <label>
                {attr.charAt(0).toUpperCase() + attr.slice(1)}:
                <select
                  value={manualAttributes[attr] !== null ? manualAttributes[attr] : ""}
                  onChange={(e) => handleManualChange(attr, e.target.value)}
                  style={{ marginLeft: '10px' }}
                >
                  <option value="">Select a value</option>
                  {getAvailableOptions(attr).map(option => (
                    <option key={option} value={option}>{option}</option>
                  ))}
                </select>
              </label>
            </div>
          ))}
        </div>
      )}

      {error && <div style={{ color: 'red', marginTop: '10px' }}>{error}</div>}

      <div style={{ marginTop: '20px' }}>
        <button onClick={handleConfirm}>Confirm Attributes</button>
      </div>
    </div>
  );
};

export default AttributeCreation;


----- .\client\src\components\AttributeCreationStarter.js -----

// client/src/components/AttributeCreationStarter.js
import React, { useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../services/api';

const AttributeCreationStarter = () => {
  const navigate = useNavigate();
  // A ref to ensure we only call createInProgressCharacter once in Strict Mode
  const hasCreatedRef = useRef(false);

  useEffect(() => {
    // This check will prevent the function from running again in dev’s Strict Mode
    if (hasCreatedRef.current) return;
    hasCreatedRef.current = true;

    const createInProgressCharacter = async () => {
      try {
        const response = await api.post('/characters/', {
          name: "Unnamed Character",
          is_complete: false,
          creation_data: { step: "attributes" }
        });
        const newCharacterId = response.data.id;
        navigate(`/characters/${newCharacterId}/attributes`);
      } catch (error) {
        console.error("Failed to create new character:", error);
      }
    };

    createInProgressCharacter();
  }, [navigate]); // Note the empty dependency array

  return (
    <div className="card">
      <p>Starting your new character...</p>
    </div>
  );
};

export default AttributeCreationStarter;


----- .\client\src\components\AttributeCreationWrapper.js -----

import React from 'react';
import { useParams } from 'react-router-dom';
import AttributeCreation from './AttributeCreation';

const AttributeCreationWrapper = () => {
  const { id } = useParams();
  return <AttributeCreation characterId={id} />;
};

export default AttributeCreationWrapper;


----- .\client\src\components\BackgroundCreation.js -----

// client/src/components/BackgroundCreation.js
import React, { useState, useEffect } from 'react';
import axios from '../services/api';
import { useNavigate, useParams } from 'react-router-dom';

const ATTRIBUTE_NAMES = ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"];
const ANY_COMBAT_OPTIONS = ["Punch", "Shoot", "Stab"];
const ANY_AVAILABLE_SKILLS = [
  "Administer", "Connect", "Drive", "Exert", "Fix", "Heal",
  "Know", "Lead", "Notice", "Perform", "Program", "Punch",
  "Shoot", "Sneak", "Stab", "Survive", "Talk", "Trade", "Work"
];

const BackgroundCreation = () => {
  const [backgrounds, setBackgrounds] = useState([]);
  const [selectedBackground, setSelectedBackground] = useState(null);
  const [mode, setMode] = useState('roll'); // 'roll' or 'manual'
  const [rollData, setRollData] = useState({ growth_rolls: [], learning_rolls: [] });
  const [computedResults, setComputedResults] = useState([]); // results from dice rolls
  const [manualChoices, setManualChoices] = useState([]); // manual pick choices
  const [error, setError] = useState(null);
  // Pending ANY picks now as an array (multiple ANY picks allowed)
  const [pendingAnySkills, setPendingAnySkills] = useState([]);
  // BONUS distributions state from Phase 2
  const [bonusDistributions, setBonusDistributions] = useState({});

  const navigate = useNavigate();
  const { id } = useParams(); // character ID

  useEffect(() => {
    axios.get('/backgrounds/')
      .then(res => setBackgrounds(res.data))
      .catch(err => setError('Failed to load backgrounds.'));
  }, []);

  const handleBackgroundSelect = (bg) => {
    setSelectedBackground(bg);
    setRollData({ growth_rolls: [], learning_rolls: [] });
    setComputedResults([]);
    setManualChoices([]);
    setError(null);
    setPendingAnySkills([]);
    setBonusDistributions({});
  };

  const rollD6 = () => Math.floor(Math.random() * 6) + 1;
  const rollD8 = () => Math.floor(Math.random() * 8) + 1;

  const handleRoll = (tableType) => {
    const totalRolls = rollData.growth_rolls.length + rollData.learning_rolls.length;
    if (totalRolls >= 3) return;

    if (tableType === 'growth') {
      const roll = rollD6();
      setRollData(prev => ({ ...prev, growth_rolls: [...prev.growth_rolls, roll] }));
      if (selectedBackground && selectedBackground.growth_table) {
        const result = selectedBackground.growth_table[String(roll)];
        if (result) {
          if (result.type === "ATTRIBUTE" &&
              ["ANY", "PHYSICAL", "MENTAL"].includes(result.category.toUpperCase())) {
            // Queue this bonus distribution result for later assignment.
            setComputedResults(prev => [...prev, result]);
          } else if (
            result.type === "SKILL" &&
            (result.name.toLowerCase() === "any" || result.name.toLowerCase() === "any_combat")
          ) {
            // Add a new ANY pick to the array.
            setPendingAnySkills(prev => [...prev, result.name.toLowerCase()]);
            setComputedResults(prev => [...prev, result]);
          } else {
            setComputedResults(prev => [...prev, result]);
          }
        }
      }
    } else if (tableType === 'learning') {
      const roll = rollD8();
      setRollData(prev => ({ ...prev, learning_rolls: [...prev.learning_rolls, roll] }));
      if (selectedBackground && selectedBackground.learning_table) {
        const result = selectedBackground.learning_table[String(roll)];
        if (result) {
          if (
            result.type === "SKILL" &&
            (result.name.toLowerCase() === "any" || result.name.toLowerCase() === "any_combat")
          ) {
            setPendingAnySkills(prev => [...prev, result.name.toLowerCase()]);
            setComputedResults(prev => [...prev, result]);
          } else {
            setComputedResults(prev => [...prev, result]);
          }
        }
      }
    }
  };

  // STEP 3 IMPLEMENTATION: Update ANY-skill selection to work with our pendingAnySkills array.
  // Also, filter out any option that was already chosen via ANY picks.
  const handleAnySkillSelection = (index, selectedSkill) => {
    // Determine which ANY skills have already been resolved:
    const resolvedAnySkills = computedResults
      .filter(r => r.type === "SKILL" && r.name.toLowerCase() !== "any" && r.name.toLowerCase() !== "any_combat")
      .map(r => r.name.toLowerCase());
    // If the selected skill is already chosen, do nothing.
    if (resolvedAnySkills.includes(selectedSkill.toLowerCase())) return;

    let anySkillCount = 0;
    setComputedResults(prevResults =>
      prevResults.map(res => {
        if (res.type === "SKILL" && (res.name.toLowerCase() === "any" || res.name.toLowerCase() === "any_combat")) {
          if (anySkillCount === index) {
            return { ...res, name: selectedSkill };
          }
          anySkillCount++;
        }
        return res;
      })
    );
    setPendingAnySkills(prev => {
      const newArray = [...prev];
      newArray.splice(index, 1);
      return newArray;
    });
  };

  // STEP 2/3: Compute bonus results (attribute bonuses) from computedResults.
  const bonusResults = computedResults.filter(
    res => res.type === "ATTRIBUTE" && res.points > 1
  );

  // Handler for bonus distribution completion for a given bonus roll index.
  const handleBonusDistributionComplete = (index, finalAssignment) => {
    setBonusDistributions(prev => ({ ...prev, [index]: {
      category: bonusResults[index].category,
      points: bonusResults[index].points,
      assigned_attributes: finalAssignment
    }}));
  };

  // Calculate allowed attributes for bonus distribution:
  let allowedAttributes = [];
  if (bonusResults.length > 0) {
    // Note: For multiple bonus rolls, each distribution will render its own UI.
    // This variable is used only in the BonusAttributeDistribution component.
    // Here we simply leave allowedAttributes empty.
  }

  // STEP 2/3: Build payload including bonus distributions only if they’re complete.
  const buildPayload = () => {
    let payload = { background_id: selectedBackground.id, mode };
    if (mode === 'roll') {
      payload.growth_rolls = rollData.growth_rolls;
      payload.learning_rolls = rollData.learning_rolls;
      payload.results = computedResults;
      // Ensure bonus distributions are complete for all bonus results.
      if (bonusResults.length > 0) {
        if (Object.keys(bonusDistributions).length !== bonusResults.length) {
          setError("Please complete bonus attribute distribution for all bonus rolls.");
          return null;
        }
        payload.bonus_distribution = Object.values(bonusDistributions);
      }
    } else {
      payload.manual_choices = manualChoices;
    }
    return payload;
  };

  const handleConfirm = () => {
    if (!selectedBackground) {
      setError("Please select a background.");
      return;
    }
    if (mode === 'roll') {
      if ((rollData.growth_rolls.length + rollData.learning_rolls.length) !== 3) {
        setError("Please roll exactly 3 times (combined).");
        return;
      }
      if (computedResults.length !== 3) {
        setError("Results are incomplete. Please complete all bonus distributions.");
        return;
      }
      if (pendingAnySkills.length > 0) {
        setError("Please select bonus skills for all ANY rolls.");
        return;
      }
      if (bonusResults.length > 0 && Object.keys(bonusDistributions).length !== bonusResults.length) {
        setError("Please complete bonus attribute distribution for all bonus rolls.");
        return;
      }
    } else {
      if (manualChoices.length !== 2) {
        setError("Please select exactly 2 manual choices.");
        return;
      }
    }
    const payload = buildPayload();
    if (!payload) return;
    console.log("Sending payload:", payload);
    axios.patch(`/characters/${id}/`, { background_selection: payload })
      .then(res => {
        navigate(`/characters/${id}/contacts`);
      })
      .catch(err => {
        console.error("Error saving background selection:", err.response.data);
        setError("Error saving background selection.");
      });
  };

  return (
    <div className="card">
      <h2>Background Selection</h2>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      {!selectedBackground ? (
        <div>
          <h3>Choose a Background:</h3>
          <ul>
            {backgrounds.map(bg => (
              <li key={bg.id}>
                <button onClick={() => handleBackgroundSelect(bg)}>
                  <strong>{bg.name}</strong>: {bg.description}<br />
                  Free Skill: {bg.free_skill}
                </button>
              </li>
            ))}
          </ul>
        </div>
      ) : (
        <div>
          <h3>{selectedBackground.name} Selected</h3>
          <p>{selectedBackground.description}</p>
          <p>Free Skill: {selectedBackground.free_skill}</p>
          <div>
            <label>
              <input
                type="radio"
                value="roll"
                checked={mode === 'roll'}
                onChange={() => { setMode('roll'); setError(null); }}
              />
              Roll-based Selection
            </label>
            <label style={{ marginLeft: '20px' }}>
              <input
                type="radio"
                value="manual"
                checked={mode === 'manual'}
                onChange={() => { setMode('manual'); setError(null); }}
              />
              Manual Selection
            </label>
          </div>
          {mode === 'roll' && (
            <div>
              <h4>Roll Dice (3 rolls total):</h4>
              <button
                onClick={() => handleRoll('growth')}
                disabled={(rollData.growth_rolls.length + rollData.learning_rolls.length) >= 3}
              >
                Roll d6 for Growth
              </button>
              <button
                onClick={() => handleRoll('learning')}
                disabled={(rollData.growth_rolls.length + rollData.learning_rolls.length) >= 3}
                style={{ marginLeft: '10px' }}
              >
                Roll d8 for Learning
              </button>
              <div>
                <p>Growth Rolls: {rollData.growth_rolls.join(', ')}</p>
                <p>Learning Rolls: {rollData.learning_rolls.join(', ')}</p>
              </div>
              {computedResults.length > 0 && (
                <div>
                  <h4>Results:</h4>
                  <ul>
                    {computedResults.map((res, idx) => (
                      <li key={idx}>
                        {res.type === "ATTRIBUTE" ? (
                          <span>+{res.points} bonus to {res.category} attribute</span>
                        ) : res.type === "SKILL" ? (
                          <span>Gain {res.points} point in skill: {res.name}</span>
                        ) : null}
                      </li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          )}
          {mode === 'manual' && (
            <div>
              <h4>Manual Choices (Select 2):</h4>
              {selectedBackground.manual_table && Object.values(selectedBackground.manual_table)
                .filter(option => option.name.toLowerCase() !== "any" && option.name.toLowerCase() !== "any combat")
                .map(option => (
                  <button
                    key={`${option.name}-${option.points}`}
                    onClick={() => {
                      if (manualChoices.length < 2) {
                        setManualChoices(prev => [...prev, option]);
                      }
                    }}
                    style={{ margin: '5px' }}
                  >
                    {option.name} ({option.points} point{option.points > 1 ? 's' : ''})
                  </button>
                ))}
              <p>Selected: {manualChoices.map(choice => choice.name).join(', ')}</p>
            </div>
          )}
          {pendingAnySkills.length > 0 && (
            <div className="card" style={{ marginTop: '20px', padding: '10px' }}>
              <h4>Select your bonus skill(s):</h4>
              {pendingAnySkills.map((anySkill, index) => {
                // STEP 3 IMPLEMENTATION: Filter out options already chosen in ANY picks.
                const resolvedAnySkills = computedResults
                  .filter(r => r.type === "SKILL" && r.name.toLowerCase() !== "any" && r.name.toLowerCase() !== "any_combat")
                  .map(r => r.name.toLowerCase());
                const skillList = (anySkill === "any_combat" ? ANY_COMBAT_OPTIONS : ANY_AVAILABLE_SKILLS)
                  .filter(skill => !resolvedAnySkills.includes(skill.toLowerCase()));
                return (
                  <div key={index} style={{ margin: '10px 0' }}>
                    <p>ANY skill pick #{index + 1} ({anySkill === "any_combat" ? 'Combat skill' : 'Any skill'}):</p>
                    {skillList.map(skill => (
                      <button
                        key={skill}
                        onClick={() => handleAnySkillSelection(index, skill)}
                        style={{ margin: '5px' }}
                      >
                        {skill}
                      </button>
                    ))}
                  </div>
                );
              })}
            </div>
          )}
          {bonusResults.length > 0 && bonusResults.map((bonusRes, index) => (
            <BonusAttributeDistribution
              key={index}
              distribution={bonusRes}
              onComplete={(finalAssignment) => handleBonusDistributionComplete(index, finalAssignment)}
            />
          ))}
          <div style={{ marginTop: '20px' }}>
            <button onClick={handleConfirm}>Confirm Background Selection</button>
          </div>
        </div>
      )}
    </div>
  );
};

export default BackgroundCreation;

// STEP 3 IMPLEMENTATION: BonusAttributeDistribution component remains largely unchanged.
const BonusAttributeDistribution = ({ distribution, onComplete }) => {
  let allowedAttributes = [];
  const category = distribution.category.toUpperCase();
  if (category === "ANY") {
    allowedAttributes = ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"];
  } else if (category === "PHYSICAL") {
    allowedAttributes = ["strength", "dexterity", "constitution"];
  } else if (category === "MENTAL") {
    allowedAttributes = ["intelligence", "wisdom", "charisma"];
  }

  const initialAssignments = allowedAttributes.reduce((acc, attr) => {
    acc[attr] = 0;
    return acc;
  }, {});
  const [assignments, setAssignments] = useState(initialAssignments);
  const totalAssigned = Object.values(assignments).reduce((sum, val) => sum + Number(val), 0);
  const isComplete = totalAssigned === distribution.points;

  const handleChange = (attr, value) => {
    const numericValue = Math.max(0, parseInt(value, 10) || 0);
    setAssignments(prev => ({ ...prev, [attr]: numericValue }));
  };

  return (
    <div className="card" style={{ marginTop: '20px', padding: '10px' }}>
      <h4>
        Distribute {distribution.points} bonus point{distribution.points > 1 ? 's' : ''} for {distribution.category} attribute:
      </h4>
      {allowedAttributes.map(attr => (
        <div key={attr} style={{ marginBottom: '10px' }}>
          <label style={{ textTransform: 'capitalize' }}>
            {attr}:
            <input
              type="number"
              min="0"
              max={distribution.points}
              value={assignments[attr]}
              onChange={(e) => handleChange(attr, e.target.value)}
              style={{ marginLeft: '10px', width: '60px' }}
            />
          </label>
        </div>
      ))}
      <p>Total assigned: {totalAssigned}</p>
      {!isComplete && (
        <p style={{ color: 'red' }}>
          Please assign exactly {distribution.points} point{distribution.points > 1 ? 's' : ''}.
        </p>
      )}
      <button onClick={() => onComplete(assignments)} disabled={!isComplete}>
        Confirm Distribution
      </button>
    </div>
  );
};

export { BonusAttributeDistribution };


----- .\client\src\components\CharacterForm.js -----

// src/components/CharacterForm.js
import React, { useState } from 'react';
import api from '../services/api';

const CharacterForm = () => {
  // Rename 'name' to 'characterName' to avoid conflict with global 'name'
  const [characterName, setCharacterName] = useState('');
  const [strength, setStrength] = useState(10);
  const [dexterity, setDexterity] = useState(10);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);

  // Moved inside the component so we can access characterName, strength, and dexterity.
  const validateForm = () => {
    let errors = {};
    if (!characterName.trim()) {
      errors.characterName = 'Name is required.';
    }
    // Ensure strength and dexterity are valid numbers.
    const strValue = parseInt(strength, 10);
    const dexValue = parseInt(dexterity, 10);
    if (isNaN(strValue) || strValue < 1) {
      errors.strength = 'Strength must be a valid number.';
    }
    if (isNaN(dexValue) || dexValue < 1) {
      errors.dexterity = 'Dexterity must be a valid number.';
    }
    return errors;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);

    const validationErrors = validateForm();
    if (Object.keys(validationErrors).length > 0) {
      // Combine errors and set error state.
      setError(Object.values(validationErrors).join(' '));
      return;
    }

    try {
      await api.post('/characters/', {
        name: characterName,
        strength: parseInt(strength, 10),
        dexterity: parseInt(dexterity, 10),
      });
      console.log('Character created:', { characterName, strength, dexterity });
      setSuccess('Character created successfully!');
      setCharacterName('');
      setStrength(10);
      setDexterity(10);
    } catch (err) {
      console.error('Error creating character:', err);
      setError(err.message || 'An error occurred');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {error && <div style={{ color: 'red' }}>Error: {error}</div>}
      {success && <div style={{ color: 'green' }}>{success}</div>}
      <div>
        <label>Name</label>
        <input
          type="text"
          value={characterName}
          onChange={(e) => setCharacterName(e.target.value)}
        />
      </div>

      <div>
        <label>Strength</label>
        <input
          type="number"
          value={strength}
          onChange={(e) => setStrength(e.target.value)}
        />
      </div>

      <div>
        <label>Dexterity</label>
        <input
          type="number"
          value={dexterity}
          onChange={(e) => setDexterity(e.target.value)}
        />
      </div>

      <button type="submit">Create Character</button>
    </form>
  );
};

export default CharacterForm;


----- .\client\src\components\CharacterList.js -----

// src/components/CharacterList.js
import React, { useEffect, useState } from 'react';
import api from '../services/api';
import { Link } from 'react-router-dom';

const CharacterList = () => {
  console.log("CharacterList is mounting!");
  const [characters, setCharacters] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchCharacters();
  }, []);

  const fetchCharacters = async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await api.get('/characters/');
      console.log('Characters fetched:', response.data);
      setCharacters(response.data);
    } catch (err) {
      console.error('Failed to load characters:', err);
      if (err.response) {
        console.error('Status:', err.response.status, 'Data:', err.response.data);
      }
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return <div className="card">Loading characters...</div>;
  }

  if (error) {
    return (
      <div className="card" style={{ color: 'red' }}>
        Error fetching characters: {error.message || 'Unknown error'}
      </div>
    );
  }

  return (
    <div className="card">
      <h2>Your Characters</h2>
      {characters.length === 0 ? (
        <div>No characters found. Try creating one.</div>
      ) : (
        <ul>
          {characters.map((char) => (
            <li key={char.id}>
              <Link to={`/characters/${char.id}`}>
                {char.name} - STR: {char.strength}, DEX: {char.dexterity}
              </Link>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default CharacterList;


----- .\client\src\components\Contacts.js -----

// client/src/components/Contacts.js
import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import api from '../services/api';

const CONTACT_OPTIONS = {
  acquaintances: 2,
  friend: 1
};

const Contacts = () => {
  const navigate = useNavigate();
  const { id: characterId } = useParams(); // Assume character id is passed via URL

  // State to hold whether the user chooses "2 Acquaintances" or "1 Friend"
  const [contactOption, setContactOption] = useState('acquaintances');
  // State for the list of contacts (each with name, relationship_type, description)
  const [contacts, setContacts] = useState([]);
  // State for error messages
  const [error, setError] = useState('');

  // Initialize contacts based on the selected option
  useEffect(() => {
    const requiredCount = CONTACT_OPTIONS[contactOption];
    const initialContacts = [];
    for (let i = 0; i < requiredCount; i++) {
      initialContacts.push({
        name: '',
        relationship_type: contactOption, // preset from the radio selection
        description: ''
      });
    }
    setContacts(initialContacts);
  }, [contactOption]);

  const handleContactChange = (index, field, value) => {
    const updatedContacts = [...contacts];
    updatedContacts[index][field] = value;
    setContacts(updatedContacts);
  };

  const handleConfirm = async (e) => {
    e.preventDefault();
    setError('');

    // Validate that each contact has a non-empty name.
    for (let i = 0; i < contacts.length; i++) {
      if (!contacts[i].name.trim()) {
        setError(`Please provide a name for Contact #${i + 1}.`);
        return;
      }
    }

    // Build payload for PATCH: include contacts array and mark the contacts step complete.
    const payload = {
      contacts: contacts,
      creation_data: { contacts_completed: true }
    };

    try {
      // Send PATCH request to update the character.
      await api.patch(`/characters/${characterId}/`, payload);
      // Navigate to the next step - placeholder for Edges.
      navigate('/edges');
    } catch (err) {
      console.error("Error updating contacts:", err);
      setError("There was an error saving your contacts. Please try again.");
    }
  };

  return (
    <div className="card">
      <h2>Contacts</h2>
      <p>Select how you’d like to start your contacts:</p>
      <div>
        <label>
          <input
            type="radio"
            value="acquaintances"
            checked={contactOption === 'acquaintances'}
            onChange={() => setContactOption('acquaintances')}
          />
          2 Acquaintances
        </label>
        <label style={{ marginLeft: '20px' }}>
          <input
            type="radio"
            value="friend"
            checked={contactOption === 'friend'}
            onChange={() => setContactOption('friend')}
          />
          1 Friend
        </label>
      </div>
      <hr />
      <form onSubmit={handleConfirm}>
        {contacts.map((contact, index) => (
          <div key={index} style={{ marginBottom: '15px' }}>
            <h4>Contact #{index + 1}</h4>
            <div>
              <label>
                Name:
                <input
                  type="text"
                  value={contact.name}
                  onChange={(e) => handleContactChange(index, 'name', e.target.value)}
                  required
                />
              </label>
            </div>
            <div>
              <label>
                Relationship Type:
                <input
                  type="text"
                  value={contact.relationship_type}
                  readOnly
                  style={{ marginLeft: '10px' }}
                />
              </label>
            </div>
            <div>
              <label>
                Description (optional):
                <input
                  type="text"
                  value={contact.description}
                  onChange={(e) => handleContactChange(index, 'description', e.target.value)}
                  style={{ marginLeft: '10px' }}
                />
              </label>
            </div>
          </div>
        ))}
        {error && <div style={{ color: 'red', marginBottom: '10px' }}>{error}</div>}
        <button type="submit">Confirm Contacts</button>
      </form>
      <div style={{ marginTop: '20px' }}>
        <p>Step 4 of [Total Steps]: Contacts</p>
      </div>
    </div>
  );
};

export default Contacts;


----- .\client\src\components\Edges.js -----

// client/src/components/Edges.js
import React from 'react';

const Edges = () => {
  return (
    <div className="card">
      <h2>Edges Selection (Coming Soon)</h2>
      <p>This is a placeholder for the Edges selection step in the character creation wizard.</p>
    </div>
  );
};

export default Edges;


----- .\client\src\components\Home.js -----

import React from 'react';

const Home = () => {
  return (
    <div className="card">
      <h2>Welcome Home!</h2>
      <p>
        This is your dashboard. More features (blog posts, campaign updates, etc.) will appear here soon.
      </p>
    </div>
  );
};

export default Home;


----- .\client\src\components\Layout.js -----

import React, { useContext } from 'react';
import { Outlet, Link } from 'react-router-dom';
import styled, { ThemeProvider } from 'styled-components';
import { AuthContext } from '../contexts/AuthContext';

// Define your theme colors (you can adjust these to match your cyberpunk aesthetic)
const theme = {
  primary: '#0fffc1', // bright cyan accent
  background: '#282c34', // dark background
  text: '#ffffff', // white text
  hover: '#ff2079', // a hot pink for hover effects
};

// Create styled components for the navigation bar
const NavBar = styled.nav`
  background-color: ${props => props.theme.background};
  padding: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
`;

const NavLink = styled(Link)`
  color: ${props => props.theme.primary};
  margin: 0 10px;
  text-decoration: none;
  font-weight: bold;
  transition: color 0.3s ease;

  &:hover {
    color: ${props => props.theme.hover};
  }
`;

const LogoutButton = styled.button`
  background: none;
  border: none;
  color: ${props => props.theme.primary};
  font-weight: bold;
  cursor: pointer;
  transition: color 0.3s ease;
  margin: 0 10px;

  &:hover {
    color: ${props => props.theme.hover};
  }
`;

const LayoutContainer = styled.div`
  min-height: 100vh;
  background-color: ${props => props.theme.background};
  color: ${props => props.theme.text};
`;

const Layout = () => {
  const { token, handleLogout } = useContext(AuthContext);

  return (
    <ThemeProvider theme={theme}>
      <LayoutContainer>
        <NavBar>
          {token ? (
            <>
              <NavLink to="/home">Home</NavLink>
              <NavLink to="/characters">Characters</NavLink>
              <NavLink to="/new">New Character</NavLink>
              <LogoutButton onClick={handleLogout}>Logout</LogoutButton>
            </>
          ) : (
            <>
              <NavLink to="/welcome">Welcome</NavLink>
              <NavLink to="/login">Login</NavLink>
              <NavLink to="/register">Register</NavLink>
            </>
          )}
        </NavBar>
        <Outlet />
      </LayoutContainer>
    </ThemeProvider>
  );
};

export default Layout;


----- .\client\src\components\Login.js -----

// src/components/Login.js
import React, { useState, useContext } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../services/api';
import { AuthContext } from '../contexts/AuthContext';

function Login({ setToken }) {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState(null);
  const { handleLogin } = useContext(AuthContext);
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);

    if (!username.trim() || !password.trim()) {
      setError('Both username and password are required.');
      return;
    }

    try {
      const response = await api.post('/token/', { username, password });
      const { access, refresh } = response.data;
      localStorage.setItem('accessToken', access);
      localStorage.setItem('refreshToken', refresh);
      handleLogin(access);
      navigate('/home');
    } catch (err) {
      console.error('Login error:', err);
      setError('Invalid username/password');
    }
  };

  return (
    <div>
      <h2>Login</h2>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      <form onSubmit={handleSubmit}>
        <div>
          <label>Username: </label>
          <input
            type="text"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
          />
        </div>
        <div>
          <label>Password: </label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
        </div>
        <button type="submit">Log In</button>
      </form>
    </div>
  );
}

export default Login;


----- .\client\src\components\NewCharacterChoice.js -----

import React from 'react';
import { Link } from 'react-router-dom';

const NewCharacterChoice = () => {
  return (
    <div className="card">
      <h2>Create a New Character</h2>
      <p>Choose how you'd like to create your character:</p>

      <div style={{ marginTop: '20px' }}>
        <Link to="/new/discover" style={{ marginRight: '20px' }}>
          <button>Discover a New Character</button>
        </Link>

        <Link to="/new/manual">
          <button>Describe an Existing Character</button>
        </Link>
      </div>
    </div>
  );
};

export default NewCharacterChoice;


----- .\client\src\components\ProtectedRoute.js -----

// ./client/src/components/ProtectedRoute.js

import React, { useContext } from 'react';
import { Navigate } from 'react-router-dom';
import { AuthContext } from '../contexts/AuthContext';

const ProtectedRoute = ({ children }) => {
  const { token } = useContext(AuthContext);

  if (!token) {
    return <Navigate to="/welcome" replace />;
  }
  return children;
};

export default ProtectedRoute;


----- .\client\src\components\Register.js -----

import React, { useState, useContext } from 'react';
import { AuthContext } from '../contexts/AuthContext';
import { useNavigate } from 'react-router-dom';
import api from '../services/api';

function Register() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [email, setEmail] = useState('');
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);
  const navigate = useNavigate();
  const { handleLogin } = useContext(AuthContext);
  const validateRegister = () => {
    let errors = {};

    if (!username.trim()) {
      errors.username = 'Username is required.';
    }
    if (!password.trim()) {
      errors.password = 'Password is required.';
    }
    if (!email.trim()) {
      errors.email = 'Email is required.';
    } else {
      // Simple email regex check
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        errors.email = 'Email format is invalid.';
      }
    }
    return errors;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);
    setSuccess(null);

    const validationErrors = validateRegister();
    if (Object.keys(validationErrors).length > 0) {
      setError(Object.values(validationErrors).join(' '));
      return;
    }

    try {
      await api.post('/register/', { username, password, email });
      const loginResponse = await api.post('/token/', { username, password });
      localStorage.setItem('accessToken', loginResponse.data.access);
      localStorage.setItem('refreshToken', loginResponse.data.refresh);
      handleLogin(loginResponse.data.access);
      navigate('/home');;
    } catch (err) {
      console.error('Registration error:', err.response.data);
      setError('Registration failed.');
    }
  };

  return (
    <div>
      <h2>Register</h2>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      {success && <div style={{ color: 'green' }}>{success}</div>}
      <form onSubmit={handleSubmit}>
        <div>
          <label>Username:</label>
          <input
            type="text"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
          />
        </div>
        <div>
          <label>Password:</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
        </div>
        <div>
          <label>Email:</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
        </div>
        <button type="submit">Sign Up</button>
      </form>
    </div>
  );
}

export default Register;


----- .\client\src\components\ViewCharacter.js -----

// client/src/components/ViewCharacter.js
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import api from '../services/api';

const ViewCharacter = () => {
  const { id } = useParams();
  const [character, setCharacter] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchCharacter = async () => {
      try {
        const response = await api.get(`/characters/${id}/`);
        setCharacter(response.data);
      } catch (err) {
        console.error('Error fetching character:', err);
        setError('Could not fetch character.');
      } finally {
        setLoading(false);
      }
    };
    fetchCharacter();
  }, [id]);

  if (loading) return <div>Loading character details...</div>;
  if (error) return <div style={{ color: 'red' }}>{error}</div>;

  return (
    <div className="card">
      <h2>{character.name}</h2>
      <h3>Attributes</h3>
      <ul>
        <li>Strength: {character.strength}</li>
        <li>Dexterity: {character.dexterity}</li>
        <li>Constitution: {character.constitution}</li>
        <li>Intelligence: {character.intelligence}</li>
        <li>Wisdom: {character.wisdom}</li>
        <li>Charisma: {character.charisma}</li>
      </ul>
      <h3>Background</h3>
      {character.background ? (
        <div>
          <p><strong>{character.background.name}</strong></p>
          <p>{character.background.description}</p>
          <p>Free Skill: {character.background.free_skill}</p>
        </div>
      ) : (
        <p>No background selected.</p>
      )}
      <h3>Contacts</h3>
      {character.contacts && character.contacts.length > 0 ? (
        <ul>
          {character.contacts.map((contact) => (
            <li key={contact.id}>
              <strong>{contact.name}</strong> ({contact.relationship_type}) – {contact.description}
            </li>
          ))}
        </ul>
      ) : (
        <p>No contacts have been added yet.</p>
      )}
      <h3>Acquired Skills</h3>
      {character.skills && character.skills.length > 0 ? (
        <ul>
          {character.skills.map((cs, index) => (
            <li key={index}>
              {cs.skill.name} – Level: {cs.level}
            </li>
          ))}
        </ul>
      ) : (
        <p>No skills acquired yet.</p>
      )}
    </div>
  );
};

export default ViewCharacter;


----- .\client\src\components\Welcome.js -----

import React from 'react';
import { Link } from 'react-router-dom';

const Welcome = () => {
  return (
    <div className="card">
      <h2>Welcome to [Your App Name]</h2>
      <p>
        Discover a platform where you can manage your characters, follow campaign updates, and read blog posts about our adventures.
      </p>
      <p>
        Please <Link to="/login">log in</Link> or <Link to="/register">register</Link> to get started.
      </p>
    </div>
  );
};

export default Welcome;


----- .\client\src\contexts\AuthContext.js -----

// ./client/src/contexts/AuthContext.js

import React, { createContext, useState } from 'react';

export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [token, setToken] = useState(localStorage.getItem('accessToken'));

  const handleLogin = (newToken) => {
    localStorage.setItem('accessToken', newToken);
    setToken(newToken);
  };

  const handleLogout = () => {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
    setToken(null);
    window.location.href = '/welcome';
  };

  return (
    <AuthContext.Provider value={{ token, setToken, handleLogin, handleLogout }}>
      {children}
    </AuthContext.Provider>
  );
};


----- .\client\src\hooks\useUserRoles.js -----

// client/src/hooks/useUserRoles.js

import { useState, useEffect } from 'react';
import axios from 'axios';

const useUserRoles = () => {
  const [roles, setRoles] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    axios.get('/api/user_roles/')
      .then(res => {
        setRoles(res.data.roles);
        setLoading(false);
      })
      .catch(err => {
        console.error("Error fetching user roles:", err);
        setLoading(false);
      });
  }, []);

  return { roles, loading };
};

export default useUserRoles;


----- .\client\src\services\api.js -----

// src/services/api.js
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://127.0.0.1:8000/api/',
  withCredentials: true,
});

// Request interceptor to attach the access token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor to refresh JWT token proactively
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // Check if error response is 401 (unauthorized) and retry flag is not set
    if (error.response && error.response.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      try {
        // Get the refresh token from localStorage
        const refreshToken = localStorage.getItem('refreshToken');
        if (refreshToken) {
          // Make a call to the refresh endpoint using a separate axios instance to avoid interceptors
          const { data } = await axios.post(
            'http://127.0.0.1:8000/api/token/refresh/',
            { refresh: refreshToken }
          );
          // Update localStorage with the new access token
          localStorage.setItem('accessToken', data.access);
          // Update the original request's authorization header
          originalRequest.headers.Authorization = `Bearer ${data.access}`;
          // Retry the original request with the new token
          return api(originalRequest);
        }
      } catch (refreshError) {
        // Optionally, clear tokens and redirect to login if refresh fails
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        window.location = '/login';
        return Promise.reject(refreshError);
      }
    }
    return Promise.reject(error);
  }
);

export default api;


----- .\server\manage.py -----

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'venture.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


----- .\server\characters\admin.py -----

# server/characters/admin.py
from django.contrib import admin
from .models import Background, Skill, Contact

admin.site.register(Background)
admin.site.register(Skill)
admin.site.register(Contact)

----- .\server\characters\apps.py -----

from django.apps import AppConfig


class CharactersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'characters'


----- .\server\characters\models.py -----

from django.db import models
from django.contrib.auth.models import User
from django.db.models import JSONField


class Background(models.Model):
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)
    free_skill = models.CharField(max_length=50)
    is_default = models.BooleanField(default=False)
    version = models.CharField(max_length=20, default="1.0.0")
    growth_table = JSONField(blank=True, null=True)
    learning_table = JSONField(blank=True, null=True)
    manual_table = JSONField(blank=True, null=True)

    def __str__(self):
        return self.name

class Archetype(models.Model):
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)

    def __str__(self):
        return self.name

class Skill(models.Model):
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)
    category = models.CharField(max_length=50, blank=True)
    default_modifier = models.IntegerField(default=-1)

    def __str__(self):
        return self.name

class Character(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='characters')
    name = models.CharField(max_length=100)
    goal = models.CharField(max_length=255, blank=True)

    # Basic Attributes
    strength = models.PositiveIntegerField(default=10)
    dexterity = models.PositiveIntegerField(default=10)
    constitution = models.PositiveIntegerField(default=10)
    intelligence = models.PositiveIntegerField(default=10)
    wisdom = models.PositiveIntegerField(default=10)
    charisma = models.PositiveIntegerField(default=10)

    # Flag to determine if character creation is complete.
    is_complete = models.BooleanField(default=False)
    # Field to store in-progress creation data (for returning to the wizard).
    creation_data = JSONField(blank=True, null=True)

    # Relationships with other character-creation components.
    background = models.ForeignKey(Background, on_delete=models.SET_NULL,
                                   null=True, blank=True, related_name='characters')
    archetypes = models.ManyToManyField(Archetype, blank=True, related_name='characters')
    skills = models.ManyToManyField(Skill, through='CharacterSkill', blank=True, related_name='characters')

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.name} ({self.user.username})"

    def contact_list(self):
        return self.contacts.all()

class CharacterSkill(models.Model):
    character = models.ForeignKey(Character, on_delete=models.CASCADE)
    skill = models.ForeignKey(Skill, on_delete=models.CASCADE)
    # 'level' represents the invested points.
    # A character with no investment (no record) is treated as -1 by default.
    # When a record exists with level=0, that is considered "Skill: Level-0" (effective modifier 0),
    # level=1 means "Skill: Level-1" (effective modifier +1), etc.
    level = models.PositiveSmallIntegerField(default=0)

    class Meta:
        unique_together = ('character', 'skill')

    def __str__(self):
        return f"{self.character.name} - {self.skill.name} (Level {self.level})"

    @property
    def effective_modifier(self):
        # If a CharacterSkill record exists, its effective modifier is simply the stored level.
        return self.level

class Modifier(models.Model):
    MODIFIER_TYPE_CHOICES = [
        ('ATTRIBUTE', 'Attribute'),
        ('SKILL', 'Skill'),
    ]
    # Indicates the source of the modifier (e.g., 'Background', 'Edge', 'Focus')
    source = models.CharField(max_length=50)
    # ID of the source record (for traceability)
    source_id = models.IntegerField()
    modifier_type = models.CharField(max_length=20, choices=MODIFIER_TYPE_CHOICES)
    # For ATTRIBUTE type, you can indicate the category (e.g., "PHYSICAL", "MENTAL", or "ANY")
    category = models.CharField(max_length=20, blank=True, null=True)
    # For SKILL type, the specific skill name if applicable (e.g., "Punch", "Shoot")
    skill_name = models.CharField(max_length=50, blank=True, null=True)
    # How many points to add (usually 1 or 2)
    points = models.IntegerField(default=0)

    def __str__(self):
        return f"{self.source} (ID: {self.source_id}) - {self.modifier_type}: {self.points}"
class Contact(models.Model):
    RELATIONSHIP_CHOICES = [
        ('acquaintance', 'Acquaintance'),
        ('friend', 'Friend'),
    ]
    character = models.ForeignKey(Character, on_delete=models.CASCADE, related_name='contacts')
    name = models.CharField(max_length=100)
    relationship_type = models.CharField(max_length=20, choices=RELATIONSHIP_CHOICES)
    description = models.TextField(blank=True)  # Optional additional context

    def __str__(self):
        return f"{self.name} ({self.get_relationship_type_display()})"


----- .\server\characters\serializers.py -----

from rest_framework import serializers
from .models import Character, CharacterSkill, Skill, Background, Contact

class ContactSerializer(serializers.ModelSerializer):
    class Meta:
        model = Contact
        fields = ['id', 'name', 'relationship_type', 'description']

class CharacterSkillSerializer(serializers.ModelSerializer):
    effective_modifier = serializers.IntegerField()

    class Meta:
        model = CharacterSkill
        fields = ['skill', 'level', 'effective_modifier']
class CharacterSkillSerializer(serializers.ModelSerializer):
    effective_modifier = serializers.IntegerField

    class Meta:
        model = CharacterSkill
        fields = ['skill', 'level', 'effective_modifier']


class CharacterSerializer(serializers.ModelSerializer):
    skills = CharacterSkillSerializer(source='characterskill_set', many=True, read_only=True)
    # Make contacts writable by removing read_only=True and setting required=False.
    contacts = ContactSerializer(many=True, required=False)

    class Meta:
        model = Character
        fields = '__all__'
        read_only_fields = ['user', 'created_at', 'updated_at']

    def update(self, instance, validated_data):
        # Pop contacts data if provided in the payload.
        contacts_data = validated_data.pop('contacts', None)

        # Perform the standard update of other fields.
        instance = super().update(instance, validated_data)

        if contacts_data is not None:
            # Enforce the SRD rule:
            # Either exactly 2 contacts of type "acquaintance" OR exactly 1 of type "friend"
            num_acquaintances = sum(1 for c in contacts_data if c.get('relationship_type') == 'acquaintance')
            num_friends = sum(1 for c in contacts_data if c.get('relationship_type') == 'friend')
            if not ((num_acquaintances == 2 and num_friends == 0) or (num_friends == 1 and num_acquaintances == 0)):
                raise serializers.ValidationError(
                    "Contacts must be either exactly two acquaintances or exactly one friend."
                )

            # Remove any existing contacts for this character.
            instance.contacts.all().delete()

            # Create new contacts from the payload.
            for contact_data in contacts_data:
                Contact.objects.create(character=instance, **contact_data)

            # Mark the contacts step as complete in creation_data.
            creation_data = instance.creation_data or {}
            creation_data['contacts_completed'] = True
            instance.creation_data = creation_data

        instance.save()
        return instance

class SkillSerializer(serializers.ModelSerializer):
    class Meta:
        model = Skill
        fields = '__all__'

class BackgroundSerializer(serializers.ModelSerializer):
    class Meta:
        model = Background
        fields = '__all__'

----- .\server\characters\tests.py -----

from django.test import TestCase

# Create your tests here.


----- .\server\characters\views.py -----

from rest_framework import viewsets, permissions, serializers
from rest_framework.response import Response
from .models import Character, Background, Skill, CharacterSkill, Contact
from .serializers import CharacterSerializer, BackgroundSerializer, SkillSerializer
from .services.modifiers import apply_modifiers

def apply_background_selection(character, selection):
    # Assign the selected background.
    background_id = selection.get('background_id')
    try:
        background = Background.objects.get(id=background_id)
    except Background.DoesNotExist:
        raise serializers.ValidationError("Invalid background_id provided.")
    character.background = background

    # Apply free skill:
    free_skill_name = background.free_skill
    try:
        free_skill = Skill.objects.get(name__iexact=free_skill_name)
    except Skill.DoesNotExist:
        raise serializers.ValidationError("The free skill defined in the background does not exist.")
    free_cs, created = CharacterSkill.objects.get_or_create(
        character=character,
        skill=free_skill,
        defaults={'level': 0}
    )
    if free_cs.level < 1:
        free_cs.level = 1
        free_cs.save()

    # Process additional results (roll-based or manual).
    if selection.get('mode') == 'roll':
        results = selection.get('results', [])
    else:
        results = selection.get('manual_choices', [])

    # Convert each result into a modifier dict.
    modifiers = []
    for item in results:
        if item.get('type') == "ATTRIBUTE":
            modifiers.append({
                'modifier_type': "ATTRIBUTE",
                'category': item.get('category'),
                'points': item.get('points', 0),
            })
        elif item.get('type') == "SKILL":
            modifiers.append({
                'modifier_type': "SKILL",
                'skill_name': item.get('name'),
                'points': item.get('points', 0),
            })
    # Apply the standard modifiers.
    apply_modifiers(character, modifiers)

    # Process bonus distribution if provided.
    bonus_distribution = selection.get('bonus_distribution')
    if bonus_distribution:
        for bonus in bonus_distribution:
            category = bonus.get('category', '').upper()
            assignments = bonus.get('assigned_attributes', {})
            bonus_points = bonus.get('points', 0)
            if sum(assignments.values()) != bonus_points:
                raise serializers.ValidationError("Total bonus assignment does not match bonus points.")
            for attr, pts in assignments.items():
                allowed_attrs = []
                if category == 'ANY':
                    allowed_attrs = ['strength', 'dexterity', 'constitution', 'intelligence', 'wisdom', 'charisma']
                elif category == 'PHYSICAL':
                    allowed_attrs = ['strength', 'dexterity', 'constitution']
                elif category == 'MENTAL':
                    allowed_attrs = ['intelligence', 'wisdom', 'charisma']
                if attr not in allowed_attrs:
                    raise serializers.ValidationError(f"Invalid attribute assignment: {attr} for category {category}.")
                current_val = getattr(character, attr)
                if current_val + pts > 18:
                    raise serializers.ValidationError(f"Assignment would exceed attribute cap for {attr}.")
                setattr(character, attr, current_val + pts)

    # Save the creation_data for traceability.
    creation_data = character.creation_data or {}
    creation_data['background_selection'] = selection
    creation_data['background_completed'] = True
    character.creation_data = creation_data
    character.save()

class SkillViewSet(viewsets.ModelViewSet):
    queryset = Skill.objects.all()
    serializer_class = SkillSerializer
    permission_classes = [permissions.IsAuthenticated]

class CharacterViewSet(viewsets.ModelViewSet):
    queryset = Character.objects.all()
    serializer_class = CharacterSerializer
    permission_classes = [permissions.IsAuthenticated]

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

    def get_queryset(self):
        if self.request.user.is_staff:
            return super().get_queryset()
        return super().get_queryset().filter(user=self.request.user)

    def update(self, request, *args, **kwargs):
        # Pop background_selection from payload if present
        background_selection = request.data.pop('background_selection', None)
        character = self.get_object()

        # Update the character with other fields (including contacts payload if provided)
        serializer = self.get_serializer(character, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        # If background_selection was sent, process it.
        if background_selection:
            try:
                apply_background_selection(character, background_selection)
            except serializers.ValidationError as e:
                return Response({"detail": e.detail}, status=400)
            # Reload serializer to reflect changes from background_selection
            serializer = self.get_serializer(character)

        return Response(serializer.data)

class BackgroundViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Background.objects.all()
    serializer_class = BackgroundSerializer
    permission_classes = [permissions.IsAuthenticated]


----- .\server\characters\__init__.py -----



----- .\server\characters\fixtures\initial_backgrounds.json -----

[
  {
    "model": "characters.background",
    "pk": 1,
    "fields": {
      "name": "Bum",
      "description": "A street-smart survivor who's lived on society's edges.",
      "free_skill": "survive",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "survive", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "any_combat", "points": 1},
        "2": {"type": "SKILL", "name": "survive", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "sneak", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "talk", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "survive", "points": 1},
        "5": {"type": "SKILL", "name": "connect", "points": 1},
        "6": {"type": "SKILL", "name": "sneak", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1},
        "8": {"type": "SKILL", "name": "talk", "points": 1},
        "9": {"type": "SKILL", "name": "fix", "points": 1},
        "10": {"type": "SKILL", "name": "ANY", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 2,
    "fields": {
      "name": "Bureaucrat",
      "description": "Placeholder",
      "free_skill": "administer",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "administer", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "administer", "points": 1},
        "2": {"type": "SKILL", "name": "know", "points": 1},
        "3": {"type": "SKILL", "name": "talk", "points": 1},
        "4": {"type": "SKILL", "name": "program", "points": 1},
        "5": {"type": "SKILL", "name": "lead", "points": 1},
        "6": {"type": "SKILL", "name": "trade", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "administer", "points": 1},
        "2": {"type": "SKILL", "name": "know", "points": 1},
        "3": {"type": "SKILL", "name": "talk", "points": 1},
        "4": {"type": "SKILL", "name": "program", "points": 1},
        "5": {"type": "SKILL", "name": "lead", "points": 1},
        "6": {"type": "SKILL", "name": "trade", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 3,
    "fields": {
      "name": "Clergy",
      "description": "Placeholder",
      "free_skill": "lead",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "connect", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "lead", "points": 1},
        "2": {"type": "SKILL", "name": "talk", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "perform", "points": 1},
        "5": {"type": "SKILL", "name": "know", "points": 1},
        "6": {"type": "SKILL", "name": "heal", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "lead", "points": 1},
        "2": {"type": "SKILL", "name": "talk", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "perform", "points": 1},
        "5": {"type": "SKILL", "name": "know", "points": 1},
        "6": {"type": "SKILL", "name": "heal", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 4,
    "fields": {
      "name": "Coder",
      "description": "A skilled programmer with a talent for solving complex problems.",
      "free_skill": "program",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "program", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "program", "points": 1},
        "2": {"type": "SKILL", "name": "administer", "points": 1},
        "3": {"type": "SKILL", "name": "fix", "points": 1},
        "4": {"type": "SKILL", "name": "talk", "points": 1},
        "5": {"type": "SKILL", "name": "connect", "points": 1},
        "6": {"type": "SKILL", "name": "know", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "program", "points": 1},
        "2": {"type": "SKILL", "name": "administer", "points": 1},
        "3": {"type": "SKILL", "name": "fix", "points": 1},
        "4": {"type": "SKILL", "name": "talk", "points": 1},
        "5": {"type": "SKILL", "name": "connect", "points": 1},
        "6": {"type": "SKILL", "name": "know", "points": 1},
        "7": {"type": "SKILL", "name": "notice", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 5,
    "fields": {
      "name": "Corp Security",
      "description": "A corporate enforcer with training in combat and protection.",
      "free_skill": "any_combat",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "any_combat", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "any_combat", "points": 1},
        "2": {"type": "SKILL", "name": "administer", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "notice", "points": 1},
        "5": {"type": "SKILL", "name": "exert", "points": 1},
        "6": {"type": "SKILL", "name": "heal", "points": 1},
        "7": {"type": "SKILL", "name": "sneak", "points": 1},
        "8": {"type": "SKILL", "name": "lead", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "administer", "points": 1},
        "5": {"type": "SKILL", "name": "connect", "points": 1},
        "6": {"type": "SKILL", "name": "notice", "points": 1},
        "7": {"type": "SKILL", "name": "exert", "points": 1},
        "8": {"type": "SKILL", "name": "heal", "points": 1},
        "9": {"type": "SKILL", "name": "sneak", "points": 1},
        "10": {"type": "SKILL", "name": "lead", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 6,
    "fields": {
      "name": "Corper",
      "description": "Placeholder",
      "free_skill": "work",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "ANY", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "work", "points": 1},
        "2": {"type": "SKILL", "name": "talk", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "any_combat", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "sneak", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "work", "points": 1},
        "2": {"type": "SKILL", "name": "talk", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "any_combat", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "sneak", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 7,
    "fields": {
      "name": "Criminal",
      "description": "Placeholder.",
      "free_skill": "sneak",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "any_combat", "points": 1},
        "2": {"type": "SKILL", "name": "sneak", "points": 1},
        "3": {"type": "SKILL", "name": "notice", "points": 1},
        "4": {"type": "SKILL", "name": "connect", "points": 1},
        "5": {"type": "SKILL", "name": "talk", "points": 1},
        "6": {"type": "SKILL", "name": "survive", "points": 1},
        "7": {"type": "SKILL", "name": "exert", "points": 1},
        "8": {"type": "SKILL", "name": "lead", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "sneak", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "talk", "points": 1},
        "8": {"type": "SKILL", "name": "survive", "points": 1},
        "9": {"type": "SKILL", "name": "exert", "points": 1},
        "10": {"type": "SKILL", "name": "lead", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 8,
    "fields": {
      "name": "Doctor",
      "description": "Placeholder",
      "free_skill": "heal",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "survive", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "heal", "points": 1},
        "2": {"type": "SKILL", "name": "notice", "points": 1},
        "3": {"type": "SKILL", "name": "know", "points": 1},
        "4": {"type": "SKILL", "name": "talk", "points": 1},
        "5": {"type": "SKILL", "name": "administer", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "heal", "points": 1},
        "2": {"type": "SKILL", "name": "notice", "points": 1},
        "3": {"type": "SKILL", "name": "know", "points": 1},
        "4": {"type": "SKILL", "name": "talk", "points": 1},
        "5": {"type": "SKILL", "name": "administer", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1}
      }}},
      {
    "model": "characters.background",
    "pk": 9,
    "fields": {
      "name": "Drone Jockey",
      "description": "Placeholder.",
      "free_skill": "drive",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "drive", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "drive", "points": 1},
        "2": {"type": "SKILL", "name": "fix", "points": 1},
        "3": {"type": "SKILL", "name": "shoot", "points": 1},
        "4": {"type": "SKILL", "name": "notice", "points": 1},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "exert", "points": 1},
        "7": {"type": "SKILL", "name": "program", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "drive", "points": 1},
        "2": {"type": "SKILL", "name": "fix", "points": 1},
        "3": {"type": "SKILL", "name": "shoot", "points": 1},
        "4": {"type": "SKILL", "name": "notice", "points": 1},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "exert", "points": 1},
        "7": {"type": "SKILL", "name": "program", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 10,
    "fields": {
      "name": "Ganger",
      "description": "Placeholder",
      "free_skill": "any_combat",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "any_combat", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "any_combat", "points": 1},
        "2": {"type": "SKILL", "name": "connect", "points": 1},
        "3": {"type": "SKILL", "name": "survive", "points": 1},
        "4": {"type": "SKILL", "name": "notice", "points": 1},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "talk", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "connect", "points": 1},
        "5": {"type": "SKILL", "name": "survive", "points": 1},
        "6": {"type": "SKILL", "name": "notice", "points": 1},
        "7": {"type": "SKILL", "name": "sneak", "points": 1},
        "8": {"type": "SKILL", "name": "talk", "points": 1},
        "9": {"type": "SKILL", "name": "fix", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 11,
    "fields": {
      "name": "Laborer",
      "description": "Placeholder.",
      "free_skill": "exert",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "exert", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "exert", "points": 1},
        "2": {"type": "SKILL", "name": "work", "points": 1},
        "3": {"type": "SKILL", "name": "sneak", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "survive", "points": 1},
        "6": {"type": "SKILL", "name": "fix", "points": 1},
        "7": {"type": "SKILL", "name": "any_combat", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "exert", "points": 1},
        "5": {"type": "SKILL", "name": "work", "points": 1},
        "6": {"type": "SKILL", "name": "sneak", "points": 1},
        "7": {"type": "SKILL", "name": "trade", "points": 1},
        "8": {"type": "SKILL", "name": "survive", "points": 1},
        "9": {"type": "SKILL", "name": "fix", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 12,
    "fields": {
      "name": "Law Enforcement",
      "description": "Placeholder.",
      "free_skill": "administer",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "administer", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "administer", "points": 1},
        "2": {"type": "SKILL", "name": "any_combat", "points": 1},
        "3": {"type": "SKILL", "name": "notice", "points": 1},
        "4": {"type": "SKILL", "name": "sneak", "points": 1},
        "5": {"type": "SKILL", "name": "talk", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "heal", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "administer", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "sneak", "points": 1},
        "7": {"type": "SKILL", "name": "talk", "points": 1},
        "8": {"type": "SKILL", "name": "connect", "points": 1},
        "9": {"type": "SKILL", "name": "heal", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 13,
    "fields": {
      "name": "Manager",
      "description": "Placeholder.",
      "free_skill": "administer",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "administer", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "administer", "points": 1},
        "2": {"type": "SKILL", "name": "talk", "points": 1},
        "3": {"type": "SKILL", "name": "trade", "points": 1},
        "4": {"type": "SKILL", "name": "connect", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "lead", "points": 1},
        "7": {"type": "SKILL", "name": "program", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "administer", "points": 1},
        "2": {"type": "SKILL", "name": "talk", "points": 1},
        "3": {"type": "SKILL", "name": "trade", "points": 1},
        "4": {"type": "SKILL", "name": "connect", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "lead", "points": 1},
        "7": {"type": "SKILL", "name": "program", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 14,
    "fields": {
      "name": "Outlander",
      "description": "Placeholder.",
      "free_skill": "survive",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "survive", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "survive", "points": 1},
        "2": {"type": "SKILL", "name": "drive", "points": 1},
        "3": {"type": "SKILL", "name": "fix", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "any_combat", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "survive", "points": 1},
        "5": {"type": "SKILL", "name": "drive", "points": 1},
        "6": {"type": "SKILL", "name": "fix", "points": 1},
        "7": {"type": "SKILL", "name": "trade", "points": 1},
        "8": {"type": "SKILL", "name": "sneak", "points": 1},
        "9": {"type": "SKILL", "name": "connect", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 15,
    "fields": {
      "name": "Performer",
      "description": "Placeholder.",
      "free_skill": "perform",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "ANY", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "perform", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "perform", "points": 1},
        "2": {"type": "SKILL", "name": "lead", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "talk", "points": 1},
        "5": {"type": "SKILL", "name": "trade", "points": 1},
        "6": {"type": "SKILL", "name": "sneak", "points": 1},
        "7": {"type": "SKILL", "name": "any_combat", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "perform", "points": 1},
        "5": {"type": "SKILL", "name": "lead", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "talk", "points": 1},
        "8": {"type": "SKILL", "name": "trade", "points": 1},
        "9": {"type": "SKILL", "name": "sneak", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 16,
    "fields": {
      "name": "Soldier",
      "description": "Placeholder.",
      "free_skill": "any_combat",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "any_combat", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "any_combat", "points": 1},
        "2": {"type": "SKILL", "name": "exert", "points": 1},
        "3": {"type": "SKILL", "name": "lead", "points": 1},
        "4": {"type": "SKILL", "name": "notice", "points": 1},
        "5": {"type": "SKILL", "name": "survive", "points": 1},
        "6": {"type": "SKILL", "name": "heal", "points": 1},
        "7": {"type": "SKILL", "name": "administer", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "exert", "points": 1},
        "5": {"type": "SKILL", "name": "lead", "points": 1},
        "6": {"type": "SKILL", "name": "notice", "points": 1},
        "7": {"type": "SKILL", "name": "survive", "points": 1},
        "8": {"type": "SKILL", "name": "heal", "points": 1},
        "9": {"type": "SKILL", "name": "administer", "points": 1}
      }}},
      {
    "model": "characters.background",
    "pk": 17,
    "fields": {
      "name": "Spy",
      "description": "Placeholder.",
      "free_skill": "sneak",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "ANY", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "sneak", "points": 1},
        "2": {"type": "SKILL", "name": "notice", "points": 1},
        "3": {"type": "SKILL", "name": "talk", "points": 1},
        "4": {"type": "SKILL", "name": "connect", "points": 1},
        "5": {"type": "SKILL", "name": "program", "points": 1},
        "6": {"type": "SKILL", "name": "exert", "points": 1},
        "7": {"type": "SKILL", "name": "any_combat", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "sneak", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "talk", "points": 1},
        "7": {"type": "SKILL", "name": "connect", "points": 1},
        "8": {"type": "SKILL", "name": "program", "points": 1},
        "9": {"type": "SKILL", "name": "exert", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 18,
    "fields": {
      "name": "Trader",
      "description": "Placeholder.",
      "free_skill": "trade",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "5": {"type": "SKILL", "name": "trade", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "trade", "points": 1},
        "2": {"type": "SKILL", "name": "notice", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "fix", "points": 1},
        "5": {"type": "SKILL", "name": "talk", "points": 1},
        "6": {"type": "SKILL", "name": "administer", "points": 1},
        "7": {"type": "SKILL", "name": "any_combat", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "punch", "points": 1},
        "2": {"type": "SKILL", "name": "shoot", "points": 1},
        "3": {"type": "SKILL", "name": "stab", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "fix", "points": 1},
        "8": {"type": "SKILL", "name": "talk", "points": 1},
        "9": {"type": "SKILL", "name": "administer", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 19,
    "fields": {
      "name": "Streetwalker",
      "description": "Placeholder.",
      "free_skill": "talk",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "ANY", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "talk", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "talk", "points": 1},
        "2": {"type": "SKILL", "name": "perform", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "notice", "points": 1},
        "7": {"type": "SKILL", "name": "heal", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "talk", "points": 1},
        "2": {"type": "SKILL", "name": "perform", "points": 1},
        "3": {"type": "SKILL", "name": "connect", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "sneak", "points": 1},
        "6": {"type": "SKILL", "name": "notice", "points": 1},
        "7": {"type": "SKILL", "name": "heal", "points": 1}
      }
    }
  },
  {
    "model": "characters.background",
    "pk": 20,
    "fields": {
      "name": "Technician",
      "description": "Placeholder.",
      "free_skill": "fix",
      "is_default": true,
      "version": "1.0.0",
      "growth_table": {
        "1": {"type": "ATTRIBUTE", "category": "ANY", "points": 1},
        "2": {"type": "ATTRIBUTE", "category": "PHYSICAL", "points": 2},
        "3": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "4": {"type": "ATTRIBUTE", "category": "MENTAL", "points": 2},
        "5": {"type": "SKILL", "name": "fix", "points": 1},
        "6": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "learning_table": {
        "1": {"type": "SKILL", "name": "fix", "points": 1},
        "2": {"type": "SKILL", "name": "program", "points": 1},
        "3": {"type": "SKILL", "name": "exert", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "drive", "points": 1},
        "8": {"type": "SKILL", "name": "ANY", "points": 1}
      },
      "manual_table": {
        "1": {"type": "SKILL", "name": "fix", "points": 1},
        "2": {"type": "SKILL", "name": "program", "points": 1},
        "3": {"type": "SKILL", "name": "exert", "points": 1},
        "4": {"type": "SKILL", "name": "trade", "points": 1},
        "5": {"type": "SKILL", "name": "notice", "points": 1},
        "6": {"type": "SKILL", "name": "connect", "points": 1},
        "7": {"type": "SKILL", "name": "drive", "points": 1}
      }
    }
  }


]


----- .\server\characters\fixtures\initial_skills.json -----

[
    {
        "model": "characters.skill",
        "pk": 1,
        "fields": {
            "name": "Administer",
            "description": "Manage an organization, handle paperwork, analyze records, and keep an institution functioning on a daily basis.",
            "category": "administrative",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 2,
        "fields": {
            "name": "Connect",
            "description": "Find people who can be helpful and get them to cooperate with you.",
            "category": "social",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 3,
        "fields": {
            "name": "Drive",
            "description": "Drive vehicles, sail ships, fly planes, pilot drones, and perform basic repairs.",
            "category": "physical",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 4,
        "fields": {
            "name": "Exert",
            "description": "Apply physical strength and stamina to feats like running, jumping, or climbing.",
            "category": "physical",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 5,
        "fields": {
            "name": "Fix",
            "description": "Create and repair devices both simple and complex.",
            "category": "technical",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 6,
        "fields": {
            "name": "Heal",
            "description": "Provide medical or psychological treatment for injuries or illnesses.",
            "category": "medical",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 7,
        "fields": {
            "name": "Know",
            "description": "Recall facts about academic or scientific topics and history.",
            "category": "knowledge",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 8,
        "fields": {
            "name": "Lead",
            "description": "Inspire and convince others to follow you.",
            "category": "social",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 9,
        "fields": {
            "name": "Notice",
            "description": "Spot details and anomalies in your environment.",
            "category": "perception",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 10,
        "fields": {
            "name": "Perform",
            "description": "Showcase performance skills such as singing, dancing, or acting.",
            "category": "artistic",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 11,
        "fields": {
            "name": "Program",
            "description": "Operate or hack computers and communications equipment.",
            "category": "technical",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 12,
        "fields": {
            "name": "Punch",
            "description": "Used in unarmed combat; without training, the modifier is -1.",
            "category": "combat",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 13,
        "fields": {
            "name": "Shoot",
            "description": "Used for ranged weapon attacks.",
            "category": "combat",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 14,
        "fields": {
            "name": "Sneak",
            "description": "Move silently and remain unseen.",
            "category": "stealth",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 15,
        "fields": {
            "name": "Stab",
            "description": "Used for melee attacks with bladed weapons.",
            "category": "combat",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 16,
        "fields": {
            "name": "Survive",
            "description": "Use street smarts or wilderness skills to stay alive.",
            "category": "survival",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 17,
        "fields": {
            "name": "Talk",
            "description": "Persuade, charm, or deceive others through conversation.",
            "category": "social",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 18,
        "fields": {
            "name": "Trade",
            "description": "Negotiate, buy, or sell goods and services.",
            "category": "economic",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 19,
        "fields": {
            "name": "Work",
            "description": "Apply your skills in a specific profession or trade.",
            "category": "labor",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 20,
        "fields": {
            "name": "Cast",
            "description": "Cast spells (for magic-enabled campaigns).",
            "category": "magical",
            "default_modifier": -1
        }
    },
    {
        "model": "characters.skill",
        "pk": 21,
        "fields": {
            "name": "Summon",
            "description": "Summon spirits or supernatural allies (for magic-enabled campaigns).",
            "category": "magical",
            "default_modifier": -1
        }
    }
]

----- .\server\characters\services\modifiers.py -----

# server/characters/services/modifiers.py

from characters.models import CharacterSkill, Skill


def apply_modifiers(character, modifiers):
    """
    Applies the given modifiers to the character.
    Per your instructions and the SRD:
    - No skill should exceed level-1 during character creation.
    - Attributes should be capped at 18.
    - 'ANY', 'PHYSICAL', or 'MENTAL' attribute bonuses are assigned on the front end,
      so we skip direct changes here unless there's a single specific attribute.
    """

    for mod in modifiers:
        if mod['modifier_type'] == 'ATTRIBUTE':
            category = mod.get('category', '').upper()
            points = mod.get('points', 0)

            # If the category is a generic 'ANY', 'PHYSICAL', or 'MENTAL',
            # we do nothing, because the front end’s bonus_distribution
            # approach handles assigning it to a specific attribute.
            # But if the category is an actual single attribute like 'STRENGTH',
            # we can do something like this:
            #
            # if category == 'STRENGTH':
            #     current_val = character.strength
            #     new_val = min(current_val + points, 18)
            #     character.strength = new_val
            #
            # (And similarly for DEXTERITY, etc.)
            # For now, we'll just skip it unless you implement that logic:
            if category not in ['ANY', 'PHYSICAL', 'MENTAL']:
                # Example: a single specific attribute category
                if category == 'STRENGTH':
                    new_val = min(character.strength + points, 18)
                    character.strength = new_val
                elif category == 'DEXTERITY':
                    new_val = min(character.dexterity + points, 18)
                    character.dexterity = new_val
                # etc. for other attributes if you want
            # Otherwise, do nothing.

        elif mod['modifier_type'] == 'SKILL':
            skill_name = mod.get('skill_name')
            if not skill_name:
                continue  # or raise an error if skill_name is missing

            try:
                skill_obj = Skill.objects.get(name__iexact=skill_name)
            except Skill.DoesNotExist:
                # If the skill doesn't exist, skip or raise an error
                continue

            # The base "points" we’re awarding
            bonus_points = mod.get('points', 0)

            cs = CharacterSkill.objects.filter(character=character, skill=skill_obj).first()
            if cs is None:
                # If we had never picked this skill at all, create a new record.
                # Typically, picking a skill once sets it to level-0, picking it twice sets to level-1,
                # so awarding 1 "point" might be enough to make it level-0 or level-1.
                if bonus_points == 1:
                    # That’s typically level-0 on the first pick
                    initial_level = 0
                else:
                    # if bonus_points >= 2, that might be enough to push it to level-1
                    initial_level = 1
                # But because you never exceed level-1 in creation:
                initial_level = min(initial_level, 1)
                CharacterSkill.objects.create(character=character, skill=skill_obj, level=initial_level)
            else:
                # If we already have the skill at level-0, awarding it again sets it to level-1,
                # but never above 1 at creation time.
                # (If you want to allow level-2 after creation, that’s a separate pipeline.)
                if cs.level == 0 and bonus_points >= 1:
                    cs.level = min(1, cs.level + 1)  # ensure it caps at level-1
                    cs.save()

    character.save()


----- .\server\users\admin.py -----

from django.contrib import admin
from django.contrib.auth.models import User
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin

class UserAdmin(BaseUserAdmin):
    list_display = ('username', 'email', 'first_name', 'last_name', 'is_staff', 'get_groups')

    def get_groups(self, obj):
        return ', '.join([g.name for g in obj.groups.all()])
    get_groups.short_description = 'Groups'

# Re-register UserAdmin
admin.site.unregister(User)
admin.site.register(User, UserAdmin)

----- .\server\users\apps.py -----

from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'users'


----- .\server\users\models.py -----

from django.db import models

# Create your models here.


----- .\server\users\serializers.py -----


from django.contrib.auth.models import User
from rest_framework import serializers


class UserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True)

    class Meta:
        model = User
        fields = ('id', 'username', 'password', 'email')  # add fields as desired

    def create(self, validated_data):
        # Use Django's create_user method which properly hashes the password
        user = User.objects.create_user(
            username=validated_data['username'],
            email=validated_data.get('email'),
            password=validated_data['password']
        )
        return user


----- .\server\users\tests.py -----

from django.test import TestCase

# Create your tests here.


----- .\server\users\views.py -----

from django.shortcuts import render
from rest_framework import viewsets, permissions, generics
from .serializers import UserSerializer
from django.contrib.auth.models import User
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def user_roles(request):
    roles = request.user.groups.values_list('name', flat=True)
    return Response({"roles": roles})

# The registration view:
class UserRegistrationView(generics.CreateAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    permission_classes = [permissions.AllowAny]  # Registration is open


----- .\server\users\__init__.py -----



----- .\server\venture\asgi.py -----

"""
ASGI config for venture project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'venture.settings')

application = get_asgi_application()


----- .\server\venture\settings.py -----

"""
Django settings for venture project.

Generated by 'django-admin startproject' using Django 5.1.7.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-odos-ixh%c^hmz0pnme-%3@c=ch9=$u8gu_0=#!=+)@htd$@9i'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # Third-party
    'rest_framework',
    'rest_framework_simplejwt.token_blacklist',
    'corsheaders',

    # Your apps
    'characters',
    'users',
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'venture.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'venture.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = 'static/'
STATICFILES_DIRS = [BASE_DIR / "static"]

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
]

CORS_ALLOW_CREDENTIALS = True

----- .\server\venture\urls.py -----

from django.contrib import admin
from django.urls import path, include
from rest_framework import routers
from characters.views import CharacterViewSet, SkillViewSet, BackgroundViewSet
from users.views import UserRegistrationView, user_roles  # <-- Import from users app
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)
from users.views import user_roles

router = routers.DefaultRouter()
router.register(r'characters', CharacterViewSet, basename='characters')
router.register(r'skills', SkillViewSet, basename='skills')
router.register(r'backgrounds', BackgroundViewSet, basename='backgrounds')

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include(router.urls)),
    path('api/register/', UserRegistrationView.as_view(), name='register'),  # <-- Comma added here
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    path('api/user_roles/', user_roles, name='user_roles'),
]


----- .\server\venture\wsgi.py -----

"""
WSGI config for venture project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'venture.settings')

application = get_wsgi_application()


----- .\server\venture\__init__.py -----

